/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["oho"] = factory();
	else
		root["oho"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ohoTips/js/common.js":
/*!**********************************!*\
  !*** ./src/ohoTips/js/common.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"common\": () => (/* binding */ common)\n/* harmony export */ });\nfunction common() {\n    this.regNum = /^[\\-, \\+]?\\d+(\\.\\d+)?([e,E][+-]?\\d+)?$/;\n    this.regNumNegative = /^\\-\\d+(\\.\\d+)?([e,E][+-]?\\d+)?$/;\n    this.regPer = /^[\\-, \\+]?((\\d+\\.?\\d*)|(\\d*\\.\\d+))([e,E][+-]?\\d+)?\\%$/;\n    this.regPerNegative = /^\\-((\\d+\\.?\\d*)|(\\d*\\.\\d+))([e,E][+-]?\\d+)?\\%$/;\n};\ncommon.prototype = {\n    noop: function() {},\n\n    isEmptyNum: function(num) {\n        if(num !== 0 && !num) {     // \"\", null, undefined, NaN\n            return true;\n        }else {\n            return false;\n        }\n    },\n\n    // 两个浮点数求和\n    numAdd: function(num1,num2){\n        let r1,r2,m;\n        try{\n            r1 = num1.toString().split('.')[1].length;\n        }catch(e){\n            r1 = 0;\n        }\n        try{\n            r2=num2.toString().split(\".\")[1].length;\n        }catch(e){\n            r2=0;\n        }\n        m=Math.pow(10,Math.max(r1,r2));\n        // return (num1*m+num2*m)/m;\n        return Math.round(num1*m+num2*m)/m;\n    },\n\n    numAdds: function(){\n        let result = arguments[0];\n\n        let i = 1;\n        for(i; i < arguments.length; i++) {\n            result = this.numAdd(result, arguments[i]);\n        }\n\n        return result;\n    },\n    \n    // 两个浮点数相减\n    numSub: function(num1,num2){\n        let r1,r2,m;\n        try{\n            r1 = num1.toString().split('.')[1].length;\n        }catch(e){\n            r1 = 0;\n        }\n        try{\n            r2=num2.toString().split(\".\")[1].length;\n        }catch(e){\n            r2=0;\n        }\n        m=Math.pow(10,Math.max(r1,r2));\n        n=(r1>=r2)?r1:r2;\n        return parseFloat((Math.round(num1*m-num2*m)/m).toFixed(n));\n    },\n\n    numSubs: function(){\n        let result = arguments[0];\n\n        let i = 1;\n        for(i; i < arguments.length; i++) {\n            result = this.numSub(result, arguments[i]);\n        }\n\n        return result;\n    },\n\n    // 两个浮点数相乘\n    numMul: function(num1,num2){\n        let m=0,s1=num1.toString(),s2=num2.toString();\n        try{\n            m+=s1.split(\".\")[1].length\n        }catch(e){\n\n        };\n        try{\n            m+=s2.split(\".\")[1].length\n        }catch(e){\n\n        };\n        return Number(s1.replace(\".\",\"\"))*Number(s2.replace(\".\",\"\"))/Math.pow(10,m);\n    },\n\n    numMuls: function(){\n        let result = arguments[0];\n\n        let i = 1;\n        for(i; i < arguments.length; i++) {\n            result = this.numMul(result, arguments[i]);\n        }\n\n        return result;\n    },\n\n    // 两个浮点数相除\n    numDiv: function(num1,num2){\n        let t1,t2,r1,r2;\n        try{\n            t1 = num1.toString().split('.')[1].length;\n        }catch(e){\n            t1 = 0;\n        }\n        try{\n            t2=num2.toString().split(\".\")[1].length;\n        }catch(e){\n            t2=0;\n        }\n        r1=Number(num1.toString().replace(\".\",\"\"));\n        r2=Number(num2.toString().replace(\".\",\"\"));\n        return (r1/r2)*Math.pow(10,t2-t1);\n    },\n\n    numDivs: function(){\n        let result = arguments[0];\n\n        let i = 1;\n        for(i; i < arguments.length; i++) {\n            result = this.numDiv(result, arguments[i]);\n        }\n\n        return result;\n    },\n\n    isNumber: function(val) {\n        let regPos = /^\\d+(\\.\\d+)?$/; //非负浮点数\n        let regNeg = /^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; //负浮点数\n        if(regPos.test(val) || regNeg.test(val)) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n\n    isString: function(value) {\n        return (typeof value == 'string') && value.constructor == String;\n    },\n\n    isArray: function(value) {\n        if (typeof Array.isArray === \"function\") {\n            return Array.isArray(value);\n        }else{\n            return Object.prototype.toString.call(value) === \"[object Array]\";\n        }\n    },\n\n    isObj: function(value) {\n        // 若value 是 null对象, type 为 \"[object Null]\"；\n        let type = Object.prototype.toString.call(value);\n        return type === \"[object Object]\";\n    },\n\n    isEmptyObj: function(value) {\n        return Object.getOwnPropertyNames(value).length == 0;\n    },\n\n    //非null对象，非数组对象\n    isObjNotArrry: function(value) {\n        return this.isObj(value) && !this.isArray(value);\n    },\n\n    extend: function(target) {\n        if(!target) {\n            console.error('No target!')\n        }\n\n        function ignore(obj) {\n            if(!obj) return false;\n\n            let isJq = false;\n            if(window.jQuery){\n                isJq = obj instanceof jQuery;\n            }\n\n            let isIgnore = isJq;\n            return isIgnore;\n        }\n\n        let objs = [].slice.call(arguments,1);\n\n        if(objs.length > 0) {\n            objs.forEach((item,index) => {\n                if(this.isObjNotArrry(item)) {\n                    for(let key in item) {\n                        if(this.isObjNotArrry(item[key]) && !ignore(item[key])) {\n                            if(! target.hasOwnProperty(key) || !this.isObjNotArrry(target[key])) target[key] = {};\n                            this.extend(target[key],item[key]);\n                        }else {\n                            target[key] = item[key];\n                        }\n                    }\n                }else {\n                    console.error('Parameter ' + index + ' is no valid arguments, expected to be object');\n                }\n            })\n        }\n\n        return target;\n    },\n\n    trim: function(str, isglobal) {\n        let result;\n        result = str.replace(/(^\\s+)|(\\s+$)/g, '');\n        if (isglobal && isglobal.toLowerCase() === 'g') {\n            result = result.replace(/\\s/g, '');\n        }\n        return result;\n    },\n\n    randomNum: function(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    },\n\n    createNode: function(htmlStr) {\n        let div = document.createElement(\"div\");\n        div.innerHTML = htmlStr;\n        return div.childNodes[0].cloneNode(true);\n    },\n\n    objToStyle: function(obj) {\n        let style = [];\n        for(let i in obj){\n            style.push(i + ':' + obj[i]);\n        }\n        style = style.join(';');\n\n        return  style;\n    },\n\n    styleToObj: function(style) {\n        if (!style || style == '') { return ''; }\n\n        let styleArr = style.split(';')\n        styleArr = styleArr.filter(item => {\n            return item != '';\n        });\n\n        let objStr = '';\n        styleArr.forEach(item => {\n            let css = '';\n            item = item.replace(/(^\\s+)|(\\s+$)/g, '');\n            this.trim(item).split(':').forEach(cssValue => {\n                css += '\"' + this.trim(cssValue) + '\":';\n            })\n            objStr += css + ',';\n        })\n        objStr = objStr.replace(/:,/g, ',');\n        objStr = objStr.substring(0, objStr.lastIndexOf(','));\n        objStr = '{' + objStr + '}';\n        return JSON.parse(objStr);\n    },\n\n    addCss: function(el, cssObj) {\n        let oldCssText = el.style.cssText;\n        oldCssText = this.styleToObj(oldCssText) || {};\n        if(oldCssText) cssObj = this.extend({}, oldCssText, cssObj);\n\n        let numberStyleArr = ['opacity'];\n        for(let i in cssObj){\n            if(numberStyleArr.indexOf(i) != -1) continue; \n            if(this.isNumber(cssObj[i])) cssObj[i] += \"px\";\n        }\n        let cssText = this.objToStyle(cssObj);\n\n        el.style.cssText = cssText;\n    },\n\n    addClass: function(el, className) {\n        if(typeof(className) == 'string') {\n            className = className.split(' ');\n        }\n\n        if(!this.isArray(className)) {\n            return false;\n        }\n\n        let oldClass = el.className.split(' ');\n        className = className.filter(item => !oldClass.includes(item));\n        if(className.length == 0) return;\n\n        className = className.join(' ');\n\n        return el.className += ' ' + className;\n    },\n\n    removeClass: function(el, className) {\n        if (el.classList) {\n            if(typeof(className) == 'string') {\n                className = className.split(' ');\n            }\n\n            if(!this.isArray(className)) {\n                return false;\n            }\n\n            className.forEach(item => {\n                el.classList.remove(className);\n            });\n        }else {\n            el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n    },\n\n    getStyle: function(el, styleAttr) {\n        let style = getComputedStyle(el);\n\n        if(!styleAttr) {\n            return style;\n        }else {\n            return style[styleAttr];\n        }\n    },\n\n    outerWidth: function(el, status) {\n        let style = getComputedStyle(el);\n        let width = parseFloat(style.width) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n\n        if(!this.isComputedPaddingEl(el)) width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n\n        if(!status) return width;\n\n        width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        return width;\n    },\n\n    outerHeight: function(el, status) {\n        let style = getComputedStyle(el);\n        let height = parseFloat(style.height) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n\n        if(!this.isComputedPaddingEl(el)) height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);\n\n        if(!status) return height;\n        \n        height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        return height;\n    },\n\n    // innerWidth: function(el, status) {\n    //     if(!status) return el.clientWidth;\n\n    //     let width = el.clientWidth;\n    //     let style = getComputedStyle(el);\n\n    //     width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n    //     return width;\n    // },\n\n    // innerHeight: function(el, status) {\n    //     if(!status) return el.clientHeight;\n\n    //     let width = el.clientHeight;\n    //     let style = getComputedStyle(el);\n\n    //     width += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);\n    //     return width;\n    // },\n\n    innerWidth: function(el, status) {\n        let style = getComputedStyle(el);\n        let width = parseFloat(style.width);\n\n        if(this.isComputedPaddingEl(el) || !status) return width;\n\n        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n        return width;\n    },\n\n    innerHeight: function(el, status) {\n        let style = getComputedStyle(el);\n        let height = parseFloat(style.height);\n\n        if(this.isComputedPaddingEl(el) || !status) return height;\n\n        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);\n        return height;\n    },\n\n    // getComputedStyle, width 和 height 已经包含Padding 的元素\n    isComputedPaddingEl: function(el) {\n        let elArr = ['button'];\n        return elArr.includes(el.localName);\n    },\n\n    // position: function(el) {\n    //     console.log(el.getBoundingClientRect(), {top: el.offsetTop, left: el.offsetLeft});\n    //     return {top: el.offsetTop, left: el.offsetLeft};\n    // },\n\n    position: function(el) {\n        let rect = el.getBoundingClientRect();\n\n        // console.trace();\n        // console.log(\"C.position: \", el, rect, {top: rect.top+scrollY, left: rect.left+scrollX});\n\n        if(this.css(el, 'position') === 'fixed') {\n            return {top: rect.top, left: rect.left};\n        } else {\n            let t;\n            let scrollX = (((t = document.documentElement) || (t = document.body.parentNode)) && typeof t.scrollLeft == 'number' ? t : document.body).scrollLeft;\n            let scrollY = (((t = document.documentElement) || (t = document.body.parentNode)) && typeof t.scrollTop == 'number' ? t : document.body).scrollTop;\n            return {top: rect.top+scrollY, left: rect.left+scrollX};\n        }\n        \n    },\n\n    css: function(el, styleName, value) {\n        if(value !== undefined) return el.style[styleName] = value;\n        else return getComputedStyle(el)[styleName];\n    },\n\n    getScrollWidth: function() {\n        var noScroll, scroll, oDiv = document.createElement(\"DIV\");\n        oDiv.style.cssText = \"position:absolute; top:-1000px; width:100px; height:100px; overflow:hidden;\";\n        noScroll = document.body.appendChild(oDiv).clientWidth;\n        oDiv.style.overflowY = \"scroll\";\n        scroll = oDiv.clientWidth;\n        document.body.removeChild(oDiv);\n        return noScroll-scroll;\n    },\n\n    hasScrollbarY: function() {\n        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);\n    },\n\n    insertAfter: function(newElement, targentElement) {\n        var parent = targentElement.parentNode;\n\n        if(parent.lastChild == targentElement) {\n            parent.appendChild(newElement);\n        }else {\n            parent.insertBefore(newElement, targentElement.nextSibling)\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack://oho/./src/ohoTips/js/common.js?");

/***/ }),

/***/ "./src/ohoTips/js/ohoTips.js":
/*!***********************************!*\
  !*** ./src/ohoTips/js/ohoTips.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ohoTips\": () => (/* binding */ ohoTips),\n/* harmony export */   \"ohoTipsPrototype\": () => (/* binding */ tips)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/ohoTips/js/common.js\");\n\n\nlet C = new _common_js__WEBPACK_IMPORTED_MODULE_0__.common();\n\n/**\n * tips 插件\n */\n    \n/**\n * 实例化方式\n * 1. 不传任何参数，则直接返回实例\n * 2. options 只传tips消息字符串或消息数组，则按默认配置弹出消息。其他配置在 extendOptions, 可选的\n * 3. options 传入完整配置对象，则按配置弹出消息，不需要 extendOptions\n * @Author   Devin\n * @param    {[type]}                 options       支持消息字符串，消息数组以及完整配置对象\n * @param    {Object}                 extendOptions 仅在消息字符串，消息数组 的情况下可选的，\n * @return   {[type]}                               [description]\n */\nfunction tips(options, extendOptions = {}) {\n    if(!options)\n        return this;\n\n    this.C = C;\n\n    // 单独传入消息\n    if(C.isString(options) || C.isArray(options)) {\n        let newOptions = {\n            message: options\n        };\n\n        options = newOptions;\n\n        if(C.isObj(extendOptions) && !C.isEmptyObj(extendOptions)) {\n            options = C.extend({}, extendOptions, options);\n        }\n    }\n\n    this.init(options);\n}\n\ntips.C = C;\n\ntips.defaultOptions = {\n    message: '',                //传入数组可换行, 支持DOM元素，jQuery元素\n    html: {\n        param: false,                   //false - 文本类型信息，true - dom元素类型信息\n        isContainerTransparent: false,  //false - Tips 容器不透明，true - Tips 容器透明\n    },\n    baseElement: \"\",            //基准方位元素\n    direction: 'inner',         //计算Tips定位时，inner - 计算Tips 宽高，尽量使Tips 位于基准元素内部，normal - 不计算Tips宽高，按照position数据来，outer - 计算Tips 宽高，尽量使Tips 位于基准元素外部, outside - 计算Tips 宽高，尽量使Tips 位于基准元素外部； 默认'inner'。\n    position: \"middle\",         //Tips 位置，左上角，上居中，右上角，左居中，全居中，右居中，左下角，下居中，右下角，自定义相对位置，浮动\n    offset: {                   //如果position 是对象如{top: 0}，则一般不需要这个，如果是字符串，则可以酌情添加offset, 调整基准元素与Tips 的相对定位, 仅支持top，left\n        top: null,\n        left: null\n    },\n    group: {                    //分组，多个Tips 集合，超出分组最大限制个数则删除最开始的Tips\n        name: null,                 //分组名称\n        maxLength: 9999,            //一个分组最大Tips个数\n    },\n    type: \"normal\",             //Tips 样式, 支持自定义样式（传入class名称）\n    limit: true,                //限制Tips 的最大宽度 400px\n    shadow: false,              //false - 没有阴影， true - 有阴影\n    background: false,          //false - 不显示遮罩层覆盖基准元素， true - 显示遮罩层覆盖基准元素\n    icon: false,                //是否显示icon, true - 按照type参数自动设置icon类型，支持字符串设置icon类型，主要是形状，如 normal，clock等\n    iconOptions: {\n        type: 'info',           //当icon 为字符串时，icon主要定制形状(也含颜色)，此时type可以额外设置icon 的色调\n        position: 'left',       //icon 的位置，支持top, left, bottom, right\n    },\n    symbol: false,              //是否显示binder, true - 默认triangle，支持字符串设置symbol类型，如 triangle等，目前仅支持triangle\n    symbolOptions: {\n        type: null,             //如果不设置，symbol则按option.type 色调，否则按该参数的色调\n        position: null,         //如果不设置，symbol则根据option.position 设置定位(不一定一样)，否则按该参数定位\n        // offset: {               //如果启用symbol，symbol不计算宽高，则可以酌情添加offset, 调整父元素与Tips 的相对定位, 仅支持top，left\n        //     top: null,\n        //     left: null\n        // }\n    },\n    destroy: \"auto\",            //auto - 自动销毁Tips，manual - 不自动销毁Tips，需手动销毁, never - 从不销毁Tips\n    delay: 2000,                //自动销毁Tips 延时，单位：ms\n    animation: {                //动画\n        in: 'default',              //Tips 显示动画\n        out: 'default',             //Tips 隐藏动画\n        fragments: {\n            type: 1,                    // 两种创建fragment 的算法，0和1，1 体验更好\n            basePix: 10,                // 对应type = 0, 最小的像素, type 1则不需要该参数\n            xCount: 10,                 // 对应type = 1, 水平fragment的个数\n            yCount: 10,                 // 对应type = 1, 垂直fragment的个数\n        },\n        delay: 1000,                //Tips 动画执行时间，延时时间删除Tips\n        customAmtFuntion: null,     //自定义Tips 动画函数\n    },\n    float: {                    //浮动参数，当position 等于 'float' 或 'translate' 时，可选；其余情况不需要 \n        type: 'default',            //可选择默认浮动方法，浮动方法支持自定义，见 customFloatType\n        customFloatOptions: null,   //自定义浮动选项\n        customFloatStatus: null,    //自定义浮动初始状态，top，left等\n        customFloatType: null,      //自定义浮动类型的方法, 参考 floatTypeDefault 方法\n    },\n    events: {\n        beforeCreated: C.noop,      //Tips 创建消息之前 触发\n        created: C.noop,            //Tips 创建消息之后 触发\n        beforeShown: C.noop,        //Tips 创建消息之后，展示之前 触发\n        shown: C.noop,              //Tips 展示之后 触发\n        beforeDestroyed: C.noop,    //Tips 销毁之前 触发\n        destroyed: C.noop,          //Tips 销毁之后 触发\n        beforeFloated: C.noop,      //Tips 每次浮动之前 触发\n        floated: C.noop,            //Tips 每次浮动之后 触发\n    },\n    debug: true                     //debug 默认打开，打开可以调试log。 error, warn 类型的log 不受此影响\n};\n\ntips._defaultOptions = null;\n\n// 设置默认参数，全局生效\ntips.setDefOptions = function(defOptions) {\n    if(!tips._defaultOptions) tips._defaultOptions = tips.defaultOptions;\n\n    tips.defaultOptions = C.extend({}, tips.defaultOptions, defOptions);\n};\n\n// 重置默认参数\ntips.resetDefOptions = function() {\n    if(tips._defaultOptions) tips.defaultOptions = C.extend({}, tips._defaultOptions);\n};\n\ntips.floatOptions = {\n    topStart: 0,                //浮动起始位置 Top\n    leftStart: 0,               //浮动起始位置 Left\n    status: true,               //浮动状态，一般用于转折点改变方向趋势\n    offsetType: '',             //每次改变状态量的类型，px 或 百分比，默认px\n    xMinThreshold: 0,           //x轴相对于基准元素的最小偏差值\n    xMaxThreshold: '',          //x轴相对于基准元素的最大偏差值\n    xOffsetLen: 1,              //x轴一次的偏差量\n    yMinThreshold: 0,           //y轴相对于基准元素的最小偏差值\n    yMaxThreshold: '',          //y轴相对于基准元素的最大偏差值\n    yOffsetLen: 1,              //y轴一次的偏差量\n    delay: 1,                   //浮动位置的时间间隔\n};\n\n/**\n * 每个Tips 实例都会查找groups数组，判断实例的组是否已经存在，存在则直接往存在的组里插入Tips\n * @type {Array}\n */\ntips.groups = [];\n\n/**\n * 调试信息需要设置 debug 配置 true, 支持任意多个消息参数\n */\ntips.prototype.writeLog = function(level, ...message) {\n    if((level != 'error' || level != 'warn') && !this.options.debug) return false;\n\n    console[level](...message);\n};\n\n/**\n * 初始化展示Tips。\n * @param    {[type]}                 options [description]\n * @return   {[type]}                         [description]\n */\ntips.prototype.init = function(options) {\n    //生成实例唯一id，方便同个组里识别彼此\n    this.id = this.uniqueId();\n\n    this.options = C.extend({}, tips.defaultOptions, options);\n    \n    this.backup = {\n        _baseElm : null,                //备份基准元素\n        _tipContainerElm : null,        //备份Tips 容器元素\n        _tipGroupElm : null,            //备份Tips 分组元素\n        _tipElm : null,                 //备份Tips 元素\n        _symbolBoxElm: null,            //备份symbol Box 元素，是Tips 元素（_tipElm）的直接子元素\n        _tipBoxElm: null,               //备份Tips Box 元素，是symbol Box 元素（_symbolBoxElm）的直接子元素\n        _symbolElm : null,              //备份symbol 元素\n        _backgroundElem: null,          //备份遮罩层元素\n        _group: {                       //备份组状态\n            isExisted: false,\n            id: null,\n        },\n        _floatStatus: {},               //备份当前定位\n    };\n\n    this.monitor = {\n        floatPosition : {},         //浮动定位，支持自定义浮动方式\n        floatTranslate : {},        //浮动定位，支持自定义浮动方式\n    };\n\n    this.tGroups = tips.groups;     //每个Tips 实例都会查找groups数组，判断实例的组是否已经存在，存在则直接往存在的组里插入Tips.groups;\n\n    this.event = null;              //触发Tips 重新定位的事件\n\n    this.initTips();\n\n    this.checkGroup();\n\n    return this;\n};\n\n/**\n * 设置消息\n * 用户不设置，则根据type 自动设置\n * @return   {[type]}                 [description]\n */\ntips.prototype.initMsg = function() {\n    if(this.options.message == \"\") {\n        switch(this.options.type) {\n            case \"success\" :    this.options.message = \"保存成功\";\n                break;\n            case \"error\" :  this.options.message = \"保存失败\";\n                break;\n            case \"warning\" :    this.options.message = \"警告\";\n                break;\n            case \"info\" :this.options.message = \"tips 小工具\";\n                break;\n            default:    this.options.message = \"tips 小工具\";\n                break;\n        }\n    }\n};\n\n/**\n * 判断是否是 Html 类型的消息\n */\ntips.prototype.isHtmlMessage = function() {\n    let options = this.options;\n\n    if(options.html === true \n        || (C.isObj(options.html) && options.html.param === true)\n        || options.message instanceof HTMLElement\n        || options.message instanceof jQuery)\n    {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * 设置Tips css 类。\n * 包括消息，图标，遮罩层，阴影，标志等\n */\ntips.prototype.setClass = function() {\n    let type = this.options.type;\n    let limit = this.options.limit;\n    let shadow = this.options.shadow;\n    let icon = this.options.icon;\n    let symbol = this.options.symbol;\n    let html = this.options.html;\n\n    // ohoTip-hide 动画用，首先设置为全透明\n    let tipClass = \"ohoTip ohoTip-hide\";\n    let tipBoxClass = \"ohoTip-box\";\n    let bgClass = \"ohoTip-bg ohoTip-hide\";\n    let messageClass = \"\";\n    let iconClass = \"\";\n    let symbolClass = \"\";\n\n    // 限制Tips 宽度或者高度\n    if(limit) {\n        tipClass = tipClass + \" ohoTip-limit\";\n    }\n    // 是否显示阴影\n    if(!shadow) {\n        tipBoxClass = tipBoxClass + ' ohoTip-box-no-shadow';\n    }\n\n    if(this.isHtmlMessage()) {\n        tipBoxClass = tipBoxClass + ' ohoTip-box-html';\n        if(C.isObj(html) && html.isContainerTransparent) tipBoxClass = tipBoxClass + ' ohoTip-box-html-transparent';\n    }\n\n    switch(type) {\n        case \"normal\" :\n            messageClass = \"ohoTip-message\";\n            iconClass = \"ohoTip-icon icon-check\";\n            symbolClass = \"ohoTip-symbol\";\n            break;\n        case \"success\" :\n            tipBoxClass = tipBoxClass + \" ohoTip-success\";\n            messageClass = \"ohoTip-message ohoTip-message-success\";\n            iconClass = \"ohoTip-icon icon-check\";\n            symbolClass = \"ohoTip-symbol symbol-success\";\n            break;\n        case \"error\" :\n            tipBoxClass = tipBoxClass + \" ohoTip-error\";\n            messageClass = \"ohoTip-message ohoTip-message-error\";\n            iconClass = \"ohoTip-icon icon-cross\";\n            symbolClass = \"ohoTip-symbol symbol-error\";\n            break;\n        case \"warning\" :\n            tipBoxClass = tipBoxClass + \" ohoTip-warning\";\n            messageClass = \"ohoTip-message ohoTip-message-warning\";\n            iconClass = \"ohoTip-icon icon-exclamation\";\n            symbolClass = \"ohoTip-symbol symbol-warning\";\n            break;\n        case \"info\" :\n            tipBoxClass = tipBoxClass + \" ohoTip-info\";  \n            messageClass = \"ohoTip-message ohoTip-message-info\";\n            iconClass = \"ohoTip-icon icon-exclamation-circle\";\n            symbolClass = \"ohoTip-symbol symbol-info\";\n            break;\n        default :\n            messageClass = type;        //用户自定义\n            iconClass = \"ohoTip-icon icon-check\";\n            symbolClass = \"ohoTip-symbol\";\n            break;\n    }\n\n    if(icon) {\n        tipBoxClass = tipBoxClass + \" ohoTip-add-icon\" + \" icon-\" + this.options.iconOptions.position;\n        // 如果icon 为true，色调基于option.type。 如果为字符串，则根据字符串设置\n        if(typeof icon == 'string') {\n            iconClass = \"ohoTip-icon\";\n            switch(icon) {\n                case \"normal\" :\n                    iconClass = iconClass + \" icon-check\";\n                    break;\n                case \"success\" :\n                    iconClass = iconClass + \" icon-check icon-success\";\n                    break;\n                case \"error\" :\n                    iconClass = iconClass + \" icon-cross icon-error\";\n                    break;\n                case \"warning\" :\n                    iconClass = iconClass + \" icon-exclamation icon-warning\";\n                    break;\n                case \"info\" :\n                    iconClass = iconClass + \" icon-exclamation-circle icon-info\";\n                    break;\n                case \"clock\" :\n                    iconClass = iconClass + \" icon-clock icon-\" + this.options.iconOptions.type;\n                    break;\n                default:\n                    iconClass = icon;   // 用户自定义\n                    break;\n            }\n        }\n    }\n\n    if(symbol) {\n        // 如果symbolOptions.type 为空，色调基于option.type。 如果为字符串，则根据字符串设置色调\n        if(this.options.symbolOptions.type) {\n            symbolClass = \"ohoTip-symbol\";\n            switch(this.options.symbolOptions.type) {\n                case \"normal\" :\n                case \"success\" :\n                case \"error\" :\n                case \"warning\" :\n                case \"info\" :\n                    symbolClass = \"ohoTip-symbol symbol-\" + this.options.symbolOptions.type;\n                    break;\n                default:\n                    symbolClass = \"ohoTip-symbol \" + this.options.symbolOptions.type;   // 用户自定义\n                    break;\n            }\n        }\n    }\n\n    // 部分类型没有启用，对应cssClass 也没用\n    let cssClass = {\n        tip: tipClass,\n        tipBox: tipBoxClass,\n        bg: bgClass,\n        message: messageClass,\n        icon: iconClass,\n        symbol: symbolClass\n    };\n\n    this.cssClass = cssClass;\n\n    return cssClass;\n};\n\n/**\n * 设置 Tips 属性\n * 比如组名\n */\ntips.prototype.setTipsAttribute = function() {\n    let group = this.options.group;\n    let tipsAttribute = {};\n    if(group.name) {\n        tipsAttribute.tipName = group.name;\n    }else {\n        tipsAttribute.tipName = new Date().getTime();\n    }\n\n    this.tipsAttribute = tipsAttribute;\n\n    return tipsAttribute;\n};\n\ntips.prototype.getBaseElememt = function(options) {\n    let $base = null;\n\n    if(!options.baseElement) {\n        $base = document.querySelector(\"body\");\n    }else if(options.baseElement instanceof HTMLElement) {\n        $base = options.baseElement;\n    }else if(window.jQuery && options.baseElement instanceof jQuery) {\n        $base = options.baseElement[0];\n    }else {\n        $base = document.querySelector(options.baseElement);\n    }\n\n    return $base;\n};\n\n// 获取组元素，同一个组的Tips 将包含在相同的组元素里面\ntips.prototype.getTipsGroup = function(options) {\n    let tipsAttribute = this.tipsAttribute;\n    let groupName = 'tipGroup-' + tipsAttribute.tipName;\n\n    let $tipGroup = document.querySelector(\"div[group-name='\"+groupName+\"']\");\n\n    if(!$tipGroup) {\n        $tipGroup = C.createNode(\"<div group-name='\"+groupName+\"' class='ohoTip-group'>\");\n    }else {\n        this.backup._group.isExisted = true;\n    }\n\n    return $tipGroup;\n};\n\n// 将Tips 和 背景元素包住，避免凌乱\ntips.prototype.getTipsContainer = function(options) {\n    let tipsAttribute = this.tipsAttribute;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $tipContainer = $tipGroup.parentNode;\n\n    if(!$tipContainer) {\n        let containerName = 'tipContainer-' + new Date().getTime();\n        $tipContainer = C.createNode(\"<div name='\"+containerName+\"' class='ohoTip-container'></div>\");\n    }\n\n    return $tipContainer;\n};\n\n/**\n * 渲染Tips 内容，支持 Dom 元素\n * 包括 消息，图标，标志箭头等\n */\ntips.prototype.renderTipsBody = function(options) {\n    let $base = this.backup._baseElm;\n    let $tipContainer = this.backup._tipContainerElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let cssClass = this.cssClass;\n    let tipsAttribute = this.tipsAttribute;\n\n    this.options.events.beforeCreated.call(this);  //Tips 创建消息之前 触发\n\n    let $tip = C.createNode(\"<div name='ohoTips' class='\"+cssClass.tip+\"'>\");\n\n    // 用于symbol 启用时，设置对应padding 给symbol 展示空间\n    let $symbolBox = C.createNode(\"<div name='symbol-box' class='ohoTip-symbol-box'></div>\");\n    this.backup._symbolBoxElm = $symbolBox;\n    $tip.appendChild($symbolBox);\n\n    let $tipBox = C.createNode(\"<div class='\"+cssClass.tipBox+\"'>\");\n    this.backup._tipBoxElm = $tipBox;\n    $symbolBox.appendChild($tipBox);\n\n    let $messageBox = C.createNode(\"<div class='\"+cssClass.message+\"'>\");\n    let $message;\n    if(this.isHtmlMessage()) {       //message 为dom元素\n        if(typeof options.message == \"string\") {\n            $message = C.createNode(options.message);\n        }else if(options.message instanceof HTMLElement) {\n            $message = options.message;\n        }else if(options.message instanceof jQuery) {\n            $message = options.message[0];\n        }\n        $messageBox.appendChild($message);\n        \n    }else {                 //message 为文本信息\n        if(C.isString(options.message)) {\n            $message = document.createElement(\"span\");\n            $message.innerText = options.message;\n            $messageBox.appendChild($message);\n        }else if (C.isArray(options.message)) {\n            for(let i=0; i<options.message.length; i++) {\n                $message = document.createElement(\"div\");\n                $message.innerText = options.message[i];\n                $messageBox.appendChild($message);\n            }\n        }\n    }\n\n    $tipBox.appendChild($messageBox);\n    this.renderIcon(options, $tipBox);\n\n    this.renderTipsSymbol(options, $tipBox);\n\n    $tipGroup.appendChild($tip);\n    $tipContainer.appendChild($tipGroup);\n\n    // 如果基准元素Postion 是Fixed，则Tips插入到基准元素内\n    // 否则插入到body 内更好\n    let pStylePosition = C.getStyle($base, 'position');\n    if(pStylePosition == 'fixed') $base.appendChild($tipContainer);         //先插入元素，然后才能获取宽度和高度\n    else document.body.appendChild($tipContainer);\n\n    this.setStyleSymbolBox();\n\n    this.options.events.created.call(this);  //Tips 创建消息之后 触发\n\n    return $tip;\n};\n\n/**\n * 渲染图标\n */\ntips.prototype.renderIcon = function(options, $tipBox) {\n    if(options.icon) {\n        let cssClass = this.cssClass;\n        let $iconBox = C.createNode(\"<div class='ohoTip-icon-box'><span><i class='\"+cssClass.icon+\"'></i></span></div>\");\n        $tipBox.appendChild($iconBox);\n    }\n}\n\n/**\n * 渲染遮罩层\n */\ntips.prototype.renderTipsBg = function(options) {\n    if(!options.background) return false;\n\n    let cssClass = this.cssClass;\n    let $base = this.backup._baseElm;\n    let $tipContainer = this.backup._tipContainerElm;\n    let $bg = C.createNode(\"<div class = '\"+cssClass.bg+\"'>\");\n    $tipContainer.appendChild($bg);\n\n    return $bg;\n};\n\n/**\n * 根据Tips定位选择标志的位置\n */\ntips.prototype.mapPositionToSymbolPosition = function(myPosition) {\n    let positionToSymbolPosition = {\n        'inner': {\n            'top-left': 'top-left',\n            'top-center': 'top-center',\n            'top-right': 'top-right',\n            'center-left': 'center-left',\n            'middle': 'middle',\n            'center-right': 'center-right',\n            'bottom-left': 'bottom-left',\n            'bottom-center': 'bottom-center',\n            'bottom-right': 'bottom-right',\n        },\n        'outer': {\n            'top-left': 'bottom-left',\n            'top-center': 'bottom-center',\n            'top-right': 'bottom-right',\n            'center-left': 'center-right',\n            'middle': 'middle',\n            'center-right': 'center-left',\n            'bottom-left': 'top-left',\n            'bottom-center': 'top-center',\n            'bottom-right': 'top-right',\n            'left-top': 'right-top',\n            'left-bottom': 'right-bottom',\n            'right-top': 'left-top',\n            'right-bottom': 'left-bottom',\n        }\n    };\n\n    if(typeof myPosition == \"string\") {\n        if(this.options.direction == 'inner' || this.options.direction == 'normal') {\n            if(positionToSymbolPosition['inner'].hasOwnProperty(myPosition)) return positionToSymbolPosition['inner'][myPosition];\n        }else if(this.options.direction == 'outer' || this.options.direction == 'outside') {\n            if(positionToSymbolPosition['outer'].hasOwnProperty(myPosition)) return positionToSymbolPosition['outer'][myPosition];\n        }\n    }\n\n    return '';\n}\n\n/**\n * 渲染标志，支持自动选择位置\n */\ntips.prototype.renderTipsSymbol = function(options, $tipBox) {\n    if(!options.symbol) return false;\n\n    let symbolClass = this.cssClass.symbol;\n    let symbol = \"triangle\";\n    if(typeof options.symbol == 'string') symbol = options.symbol;\n\n    if(!this.options.symbolOptions.position && typeof this.options.position == 'string') {\n        symbolClass = symbolClass + \" \" + symbol + \"-\" + this.mapPositionToSymbolPosition(this.options.position);\n        this.writeLog('info', 'renderTipsSymbol - Auto set by options.position(%s) - Set symbolClass(%s)', this.options.position, symbolClass);\n    }else if(this.options.symbolOptions.position && typeof this.options.symbolOptions.position == 'string') {\n        symbolClass = symbolClass + \" \" + symbol + \"-\" + this.options.symbolOptions.position;\n        this.writeLog('info', 'renderTipsSymbol - Auto set by symbolOptions.position(%s) - Set symbolClass(%s)', this.options.symbolOptions.position, symbolClass);\n    }else {\n        symbolClass = symbolClass + \" \" + symbol;\n        this.writeLog('info', 'renderTipsSymbol - Auto set by symbolClass(%s), symbol(%s) - Set symbolClass(%s)', symbolClass, symbol, symbolClass);\n    }\n\n    let $symbol = C.createNode(\"<span class='\"+ symbolClass +\"'></span>\");\n    this.backup._symbolElm = $symbol;\n    $tipBox.appendChild($symbol);\n    \n    return $symbol;\n}\n\n/**\n * 设置标志父元素盒子的大小，依靠padding撑开父元素，利于动画执行\n */\ntips.prototype.setStyleSymbolBox = function() {\n    if(!this.options.symbol) return false;\n\n    let $symbolBox = this.backup._symbolBoxElm;\n    let symbolSize = this.getSymbolSize();\n\n    let symbolBoxStyle = {\n        'padding-top': 0,\n        'padding-bottom': 0,\n        'padding-left': 0,\n        'padding-right': 0,\n    };\n\n    let symbolPosition = this.options.symbolOptions.position || this.mapPositionToSymbolPosition(this.options.position);\n    if(symbolPosition && typeof symbolPosition == 'string') {\n        switch(symbolPosition) {\n                case \"top-left\" :           //坐标在Tips 的左上角位置\n                case \"top-center\" :         //坐标在Tips 的上中位置\n                case \"top-right\" :          //坐标在Tips 的右上角位置\n                    symbolBoxStyle['padding-top'] = symbolSize.height + \"px\";\n                    break;\n                case \"right-top\" :          //坐标在Tips 的上右角位置\n                case \"center-right\" :       //坐标在Tips 的右中位置\n                case \"right-bottom\" :       //坐标在Tips 的下右角位置\n                    symbolBoxStyle['padding-right'] = symbolSize.width + \"px\";\n                    break;\n                case \"bottom-right\" :       //坐标在Tips 的右下角位置\n                case \"bottom-center\" :      //坐标在Tips 的下中位置\n                case \"bottom-left\" :        //坐标在Tips 的左下角位置\n                    symbolBoxStyle['padding-bottom'] = symbolSize.height + \"px\";\n                    break;\n                case \"left-bottom\" :        //坐标在Tips 的下左角位置\n                case \"center-left\" :        //坐标在Tips 的左中位置\n                case \"left-top\" :           //坐标在Tips 的上左角位置\n                    symbolBoxStyle['padding-left'] = symbolSize.width + \"px\";\n                    break;\n                case \"middle\" :             //坐标在Tips 的中间位置\n                    break;\n                default :                   //默认坐标在Tips 的中间位置\n                    break;\n            }\n    }\n\n    C.addCss($symbolBox, symbolBoxStyle);\n\n    return symbolBoxStyle;\n}\n\n/**\n * 如果Tips 有分组配置，就将相同组的Tips 实例存入group 数组。\n */\ntips.prototype.setGroup = function() {\n    let _this = this;\n\n    let group = this.options.group;\n\n    if(group.name) {\n        if(this.tGroups.hasOwnProperty(group.name)) {\n            this.tGroups[group.name].push(_this);\n        }else {\n            this.tGroups[group.name] = [_this];\n        }\n    }\n}\n\n/**\n * 销毁Tips 的时候，\n * 从分组里面移除这个 Tips\n */\ntips.prototype.unsetGroup = function() {\n    let _this = this;\n\n    let group = this.options.group;\n\n    if(group.name) {\n        if(this.tGroups.hasOwnProperty(group.name)) {\n            for (let i = 0; i < this.tGroups[group.name].length; i++) {\n                if(this.tGroups[group.name][i].id == this.id) {\n                    this.tGroups[group.name].splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n}\n\n/**\n * 如果Tips 有分组配置，创建之后需要检查当前分组个数是否已经超出最大个数\n * 如果超出，则将最前面的Tips 销毁删除\n */\ntips.prototype.checkGroup = function() {\n    let _this = this;\n\n    let group = this.options.group;\n\n    if(group.name) {\n        if(this.tGroups.hasOwnProperty(group.name) && this.tGroups[group.name].length > group.maxLength) {\n            this.tGroups[group.name][0].destroy(_this);\n            this.tGroups[group.name].splice(0, 1);\n        }\n    }\n}\n\n/**\n * 判断Tips 基准元素是否是 Body 元素\n */\ntips.prototype.isBodyElement = function() {\n    return !this.options.baseElement || this.backup._baseElm.tagName == 'BODY';\n}\n\n/**\n * 获取基准元素以及Tips元素的详情\n * 包括位置，宽高，边宽属性等\n */\ntips.prototype.getElementDetails = function() {\n    //当基准元素或Tips 元素发生或可能发生变化时，才重新获取详细参数。\n    //一般来说，scroll 是不需要重新获取详情的，因为它不会改变基准元素的大小。只有当基准元素位于position:fixed 的父元素内，才会需要重新获取。\n    if(this.elementDetails && (!this.event || (this.event.type != 'resize' && this.event.type != 'scroll'))) {\n        return this.elementDetails;\n    }\n\n    this.setInitPosition();\n\n    let $pElem = this.backup._baseElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $tip = this.backup._tipElm;\n    let details;\n\n    if(this.isBodyElement()) {\n        details = {\n            basePosition: {top: 0, left: 0},\n            baseMarginTop: 0,           //获取基准元素外边距，position() 获取的值不算外边距\n            baseMarginLeft: 0,\n            baseWidth: document.documentElement.clientWidth,                                //width+padding\n            baseHeight: document.documentElement.clientHeight,                              //height+padding\n            baseOuterWidth: document.documentElement.clientWidth,\n            baseOuterHeight: document.documentElement.clientHeight,\n            // baseOffsetWidth: document.documentElement.offsetWidth,\n            // baseOffsetHeight: document.documentElement.offsetHeight,\n            baseBorderTopWidth: 0,           //top border\n            baseBorderBottomWidth: 0,\n            baseBorderLeftWidth: 0,          //left border\n            baseBorderRightWidth: 0,\n            baseBorderRadius: 0,                    //圆角半径\n            tipGroupWidth: C.outerWidth($tipGroup),\n            tipGroupHeight: C.outerHeight($tipGroup),\n            tipWidth: C.outerWidth($tip),\n            tipHeight: C.outerHeight($tip),\n        };\n    }else {\n        details = {\n            basePosition: C.position($pElem),\n            baseMarginTop: parseFloat(C.css($pElem, \"margin-top\")),            //获取基准元素外边距，position() 获取的值不算外边距\n            baseMarginLeft: parseFloat(C.css($pElem, \"margin-left\")),\n            baseWidth: C.innerWidth($pElem, true),                                   //width+padding\n            baseHeight: C.innerHeight($pElem, true),                                 //height+padding\n            baseOuterWidth: C.outerWidth($pElem),\n            baseOuterHeight: C.outerHeight($pElem),\n            baseBorderTopWidth: parseFloat(C.css($pElem, \"border-top-width\")),            //top border\n            baseBorderBottomWidth: parseFloat(C.css($pElem, \"border-bottom-width\")),\n            baseBorderLeftWidth: parseFloat(C.css($pElem, \"border-left-width\")),           //left border\n            baseBorderRightWidth: parseFloat(C.css($pElem, \"border-right-width\")),\n            baseBorderRadius: C.css($pElem, \"border-radius\"),                     //圆角半径\n            tipGroupWidth: C.outerWidth($tipGroup),\n            tipGroupHeight: C.outerHeight($tipGroup),\n            tipWidth: C.outerWidth($tip),\n            tipHeight: C.outerHeight($tip),\n        };\n    }\n\n    //补算外边距\n    details.baseTop = details.basePosition.top;\n    details.baseLeft = details.basePosition.left;\n\n    //tips元素position阈值，大于该阈值，tips会超出基准元素\n    details.topThreshold = details.baseHeight - details.tipGroupHeight;\n    details.leftThreshold = details.baseWidth - details.tipGroupWidth;\n\n    this.elementDetails = details;\n\n    this.unsetInitPosition();\n\n    this.writeLog('info', 'Get Element Details: ', this.elementDetails);\n\n    return this.elementDetails;\n};\n\n/**\n * 获取Tips 的css 定位类，只有以body 为基准元素的Tips 需要\n */\ntips.prototype.getPositionClass = function(myPosition) {\n    let positionClass = {};\n\n    if(this.isBodyElement()) {\n        positionClass.tipClass = \"ohoTip-fixed\";\n        positionClass.bgClass = \"ohoTip-bg-fixed\";\n\n        if(typeof myPosition == \"string\") {\n            switch(myPosition) {\n                case \"top-left\" :           //坐标在基准元素的左上角位置\n                case \"top-center\" :         //坐标在基准元素的上中位置\n                case \"top-right\" :          //坐标在基准元素的右上角位置\n                case \"center-left\" :        //坐标在基准元素的左中位置\n                case \"middle\" :             //坐标在基准元素的中间位置\n                case \"center-right\" :       //坐标在基准元素的右中位置\n                case \"bottom-left\" :        //坐标在基准元素的左下角位置\n                case \"bottom-center\" :      //坐标在基准元素的下中位置\n                case \"bottom-right\" :       //坐标在基准元素的右下角位置\n                    positionClass.tipClass = positionClass.tipClass + ' ' + myPosition;\n                    break;\n                case \"default\" :            //默认坐标在基准元素的中间位置\n                    positionClass.tipClass = positionClass.tipClass + ' ' + \"middle\";\n                    break;\n                default :                   //可支持自定义\n                    positionClass.tipClass = positionClass.tipClass + ' ' + myPosition;\n                    break;\n            }\n        }\n    }\n\n    return positionClass;\n};\n\n/**\n * 如果以Body 为基准元素，Tips 以css 类设置定位\n * 这个方法可以设置像素级别的定位偏移\n */\ntips.prototype.setClassPositionOffset = function() {\n    let $tipGroup = this.backup._tipGroupElm;\n    let myPosition = this.options.position;\n    let offset = this.options.offset;\n    offset.top = offset.top || 0;\n    offset.left = offset.left || 0;\n\n    if(offset.top == 0 && offset.left == 0) return;\n\n    if(this.isBodyElement()) {\n        if(typeof myPosition == \"string\") {\n            switch(myPosition) {\n                case \"top-left\" :           //坐标在基准元素的左上角位置\n                    $tipGroup.style.top = offset.top + \"px\";\n                    $tipGroup.style.left = offset.left + \"px\";\n                    break;\n                case \"top-center\" :         //坐标在基准元素的上中位置\n                    $tipGroup.style.top = offset.top + \"px\";\n                    $tipGroup.style.right = offset.left + \"px\";\n                    break;\n                case \"top-right\" :          //坐标在基准元素的右上角位置\n                    $tipGroup.style.top = offset.top + \"px\";\n                    $tipGroup.style.right = offset.left + \"px\";\n                    break;\n                case \"center-left\" :        //坐标在基准元素的左中位置\n                    $tipGroup.style.left = offset.left + \"px\";\n                    break;\n                case \"middle\" :             //坐标在基准元素的中间位置\n                    break;\n                case \"center-right\" :       //坐标在基准元素的右中位置\n                    $tipGroup.style.right = offset.left + \"px\";\n                    break;\n                case \"bottom-left\" :        //坐标在基准元素的左下角位置\n                    $tipGroup.style.bottom = offset.top + \"px\";\n                    $tipGroup.style.left = offset.left + \"px\";\n                    break;\n                case \"bottom-center\" :      //坐标在基准元素的下中位置\n                    $tipGroup.style.bottom = offset.top + \"px\";\n                    break;\n                case \"bottom-right\" :       //坐标在基准元素的右下角位置\n                    $tipGroup.style.bottom = offset.top + \"px\";\n                    $tipGroup.style.right = offset.left + \"px\";\n                    break;\n                case \"default\" :            //默认坐标在基准元素的中间位置\n                    break;\n                default :                   //可支持自定义\n                    break;\n            }\n        }\n    }\n}\n\n/**\n * 已弃用。替代方案是根据Symbol 设置padding，利于动画执行\n * \n * 如果启动symbol，而symbol 不占Tips 宽度和高度。 则可根据symbol offset 微调基准元素与Tips 的相对定位\n */\ntips.prototype.setClassSymbolOffset = function() {\n    // 一个分组只需要设置一次symbol offset\n    if(this.backup._group.isExisted == true) return false;\n    if(!this.options.symbol) return false;\n\n    let $tipGroup = this.backup._tipGroupElm;\n    let tgStyle = C.getStyle($tipGroup);\n    // 优先设置position.offset, 所以需要先计算当前定位\n    let tgPosition = {\n        top: parseFloat(tgStyle.top),\n        left: parseFloat(tgStyle.left),\n        right: parseFloat(tgStyle.right),\n        bottom: parseFloat(tgStyle.bottom),\n    }\n\n    if(this.isBodyElement()) {\n        let symbolSize = this.getSymbolSize();\n\n        let symbolPosition = this.options.symbolOptions.position || this.mapPositionToSymbolPosition(this.options.position);\n        if(symbolPosition && typeof symbolPosition == 'string') {\n            switch(symbolPosition) {\n                case \"top-left\" :           //坐标在Tips 的左上角位置\n                case \"top-center\" :         //坐标在Tips 的上中位置\n                case \"top-right\" :          //坐标在Tips 的右上角位置\n                    $tipGroup.style.top = tgPosition.top + symbolSize.height + \"px\";\n                    break;\n                case \"right-top\" :          //坐标在Tips 的上右角位置\n                case \"center-right\" :       //坐标在Tips 的右中位置\n                case \"right-bottom\" :       //坐标在Tips 的下右角位置\n                    $tipGroup.style.right = tgPosition.right + symbolSize.width + \"px\";\n                    break;\n                case \"bottom-right\" :       //坐标在Tips 的右下角位置\n                case \"bottom-center\" :      //坐标在Tips 的下中位置\n                case \"bottom-left\" :        //坐标在Tips 的左下角位置\n                    $tipGroup.style.bottom = tgPosition.bottom + symbolSize.height + \"px\";\n                    break;\n                case \"left-bottom\" :        //坐标在Tips 的下左角位置\n                case \"center-left\" :        //坐标在Tips 的左中位置\n                case \"left-top\" :           //坐标在Tips 的上左角位置\n                    $tipGroup.style.left = tgPosition.left + symbolSize.width + \"px\";\n                    break;\n                case \"middle\" :             //坐标在Tips 的中间位置\n                    break;\n                default :                   //默认坐标在Tips 的中间位置\n                    break;\n            }\n        }\n    }\n}\n\n/**\n * Position Fixed 只需要设置一次 offset\n */\ntips.prototype.setClassOffset = function() {\n    if(!this.hasOwnProperty('hasSetClassOffset')) {\n        this.setClassPositionOffset();\n        // this.setClassSymbolOffset();\n        this.hasSetClassOffset = true;\n    }\n}\n\n/**\n * 计算Tips位置，支持特殊定位，自定义像素级定位和百分比定位，支持top,left,bottom,right\n * 定位结果是top和left定位，不采用bottom和right定位\n * @Author   Devin\n * @DateTime 2020-01-09T21:35:47+0800\n * @param    {[mixed]}              myPosition   [relative position obj or position string]\n * @param    {[Boolean]}            calculateTip [If false, do not calculate Tips width and height]\n * @param    {[Boolean]}            force        [If true, get position style forcibly even base element is BODY]\n * @return   {[Object]}             [Position object]\n */\ntips.prototype.getPositionStyle = function(myPosition, calculateTip, force) {\n    if(((this.isBodyElement()) && typeof myPosition == \"string\") && !force) {\n        return {};\n    }\n\n    let tipPosition = {         //tip position\n        top: \"auto\",\n        bottom: \"auto\",\n        left: \"auto\",\n        right: \"auto\"\n    };\n\n    //计算tip的坐标\n    if(typeof myPosition == \"string\") {\n        if(this.options.direction == \"outer\") {\n            this.getPosStyleOuter(myPosition, calculateTip, tipPosition);\n        }else {\n            this.getPosStyleInner(myPosition, calculateTip, tipPosition);\n        }\n    }else {     //自定义坐标，支持百分比\n        let posStyleType = 'getPosStyle' + this.options.direction.charAt(0).toUpperCase() + this.options.direction.slice(1);\n        if(this[posStyleType]) {\n            this[posStyleType](myPosition, calculateTip, tipPosition);\n        }else {\n            this.getPosStyleInner(myPosition, calculateTip, tipPosition);\n        }\n    }\n\n    this.setStylePositionOffset(tipPosition);\n    // this.setStyleSymbolOffset(tipPosition);\n\n    return tipPosition;\n};\n\n/**\n * 内部定位\n * 正数 top, left, bottom, right 表示往基准元素内部方向走，负数表示相反方向\n */\ntips.prototype.getPosStyleInner = function(myPosition, calculateTip, tipPosition) {\n    let regNum = C.regNum;\n    let regPer = C.regPer;\n    let regPerNegative = C.regPerNegative;\n\n    let eleDetails = this.getElementDetails();\n\n    let tipGroupWidth = eleDetails.tipGroupWidth;\n    let tipGroupHeight = eleDetails.tipGroupHeight;\n    if(calculateTip === false) {\n        tipGroupWidth = 0;\n        tipGroupHeight = 0;\n    }\n\n    if(typeof myPosition == \"string\") {\n        switch(myPosition) {\n            case \"top-left\" :           //坐标在基准元素的左上角位置\n                tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth;\n                tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth;\n                break;\n            case \"top-center\" :         //坐标在基准元素的上中位置\n                tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth;\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseWidth/2 + eleDetails.baseBorderLeftWidth - tipGroupWidth/2);\n                break;\n            case \"top-right\" :          //坐标在基准元素的右上角位置\n                tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth;\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseBorderLeftWidth + eleDetails.baseWidth) - tipGroupWidth;\n                break;\n            case \"center-left\" :        //坐标在基准元素的左中位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseHeight/2 + eleDetails.baseBorderTopWidth - tipGroupHeight/2);\n                tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth;\n                break;\n            case \"middle\" :             //坐标在基准元素的中间位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseHeight/2 + eleDetails.baseBorderTopWidth - tipGroupHeight/2);\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseWidth/2 + eleDetails.baseBorderLeftWidth - tipGroupWidth/2);\n                break;\n            case \"center-right\" :       //坐标在基准元素的右中位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseHeight/2 + eleDetails.baseBorderTopWidth - tipGroupHeight/2);\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseBorderLeftWidth + eleDetails.baseWidth) - tipGroupWidth;\n                break;\n            case \"bottom-left\" :        //坐标在基准元素的左下角位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseBorderTopWidth + eleDetails.baseHeight) - tipGroupHeight;\n                tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth;\n                break;\n            case \"bottom-center\" :      //坐标在基准元素的下中位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseBorderTopWidth + eleDetails.baseHeight) - tipGroupHeight;\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseWidth/2 + eleDetails.baseBorderLeftWidth - tipGroupWidth/2);\n                break;\n            case \"bottom-right\" :       //坐标在基准元素的右下角位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseBorderTopWidth + eleDetails.baseHeight) - tipGroupHeight;\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseBorderLeftWidth + eleDetails.baseWidth) - tipGroupWidth;\n                break;\n            default :                   //默认坐标在基准元素的中间位置\n                tipPosition.top = eleDetails.baseTop + (eleDetails.baseHeight/2 + eleDetails.baseBorderTopWidth - tipGroupHeight/2);\n                tipPosition.left = eleDetails.baseLeft + (eleDetails.baseWidth/2 + eleDetails.baseBorderLeftWidth - tipGroupWidth/2);\n                break;\n        }\n\n        return tipPosition;\n    }\n\n    if(myPosition.hasOwnProperty('bottom') && regNum.test(myPosition.bottom)) {\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseHeight - tipGroupHeight - parseFloat(myPosition.bottom);\n    }else if(myPosition.hasOwnProperty('bottom') && regPer.test(myPosition.bottom)) {\n        let bottom = (eleDetails.baseHeight - tipGroupHeight) * parseFloat(myPosition.bottom)/100;\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseHeight - tipGroupHeight - bottom;\n    }else if(myPosition.hasOwnProperty('top') && regNum.test(myPosition.top)) {\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + parseFloat(myPosition.top);\n    }else if(myPosition.hasOwnProperty('top') && regPer.test(myPosition.top)) {\n        let top = (eleDetails.baseHeight - tipGroupHeight) * parseFloat(myPosition.top)/100;\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + top;\n    }\n\n    if(myPosition.hasOwnProperty('right') && regNum.test(myPosition.right)) {\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseWidth - tipGroupWidth - parseFloat(myPosition.right);\n    }else if(myPosition.hasOwnProperty('right') && regPer.test(myPosition.right)) {\n        let right = (eleDetails.baseWidth - tipGroupWidth) * parseFloat(myPosition.right)/100;\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseWidth - tipGroupWidth - right;\n    }else if(myPosition.hasOwnProperty('left') && regNum.test(myPosition.left)) {\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + parseFloat(myPosition.left);\n    }else if(myPosition.hasOwnProperty('left') && regPer.test(myPosition.left)) {\n        let left = (eleDetails.baseWidth - tipGroupWidth) * parseFloat(myPosition.left)/100;\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + left;\n    }\n\n    return tipPosition;\n}\n\n/**\n * 普通定位\n * 正数 top, left 表示往基准元素内部方向走，负数表示相反方向，与内部定位相同\n * 正数 bottom，right 表示以基准元素外部方向走，负数表示相反方向，与内部方向相反\n */\ntips.prototype.getPosStyleNormal = function(myPosition, calculateTip, tipPosition) {\n    let regNum = C.regNum;\n    let regPer = C.regPer;\n    let regPerNegative = C.regPerNegative;\n\n    let eleDetails = this.getElementDetails();\n\n    let tipGroupWidth = eleDetails.tipGroupWidth;\n    let tipGroupHeight = eleDetails.tipGroupHeight;\n    if(calculateTip === false) {\n        tipGroupWidth = 0;\n        tipGroupHeight = 0;\n    }\n\n    if(myPosition.hasOwnProperty('bottom')  && regNum.test(myPosition.bottom)) {\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseHeight + eleDetails.baseBorderTopWidth + eleDetails.baseBorderBottomWidth + parseFloat(myPosition.bottom);\n    }else if(myPosition.hasOwnProperty('bottom') && regPer.test(myPosition.bottom)) {\n        let baseHeight = C.numAdds(eleDetails.baseHeight, eleDetails.baseBorderTopWidth, eleDetails.baseBorderBottomWidth);\n        let bottom = C.numMul(baseHeight, C.numDiv(parseFloat(myPosition.bottom), 100));\n        tipPosition.top = C.numAdds(eleDetails.baseTop, baseHeight, bottom);\n    }else if(myPosition.hasOwnProperty('top') && regNum.test(myPosition.top)) {\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + parseFloat(myPosition.top);\n    }else if(myPosition.hasOwnProperty('top') && regPer.test(myPosition.top)) {\n        let top = (eleDetails.baseHeight - tipGroupHeight) * parseFloat(myPosition.top)/100;\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + top;\n    }\n\n    if(myPosition.hasOwnProperty('right')  && regNum.test(myPosition.right)) {\n        tipPosition.left = C.numAdds(eleDetails.baseLeft, eleDetails.baseWidth, eleDetails.baseBorderLeftWidth, eleDetails.baseBorderRightWidth, parseFloat(myPosition.right));\n    }else if(myPosition.hasOwnProperty('right') && regPer.test(myPosition.right)) {\n        let baseWidth = C.numAdds(eleDetails.baseWidth, eleDetails.baseBorderLeftWidth, eleDetails.baseBorderRightWidth);\n        let right = C.numMul(baseWidth, C.numDiv(parseFloat(myPosition.right), 100));\n        tipPosition.left = C.numAdds(eleDetails.baseLeft, baseWidth, right);\n    }else if(myPosition.hasOwnProperty('left') && regNum.test(myPosition.left)) {\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + parseFloat(myPosition.left);\n    }else if(myPosition.hasOwnProperty('left') && regPer.test(myPosition.left)) {\n        let left = (eleDetails.baseWidth - tipGroupWidth) * parseFloat(myPosition.left)/100;\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + left;\n    }\n\n    return tipPosition;\n}\n\n/**\n * 外部定位，所有定位以基准元素外为准，百分比基准也是基准元素\n * top, left, bottom, right 都是以基准元素的对应边框为准，且忽略边框厚度\n * 比如top，正数X时，表示Tip 底部高于基准元素的顶部 X；负数-X时，表示基准元素顶部低于Tip顶部 X\n */\ntips.prototype.getPosStyleOutside = function(myPosition, calculateTip, tipPosition) {\n    let regNum = C.regNum;\n    let regNumNegative = C.regNumNegative;\n    let regPer = C.regPer;\n    let regPerNegative = C.regPerNegative;\n\n    let eleDetails = this.getElementDetails();\n\n    let tipGroupWidth = eleDetails.tipGroupWidth;\n    let tipGroupHeight = eleDetails.tipGroupHeight;\n    if(calculateTip === false) {\n        tipGroupWidth = 0;\n        tipGroupHeight = 0;\n    }\n\n    if(myPosition.hasOwnProperty('bottom') && regNum.test(myPosition.bottom)) {\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseHeight + eleDetails.baseBorderBottomWidth + parseFloat(myPosition.bottom);\n        if(regNumNegative.test(myPosition.bottom)) {\n            tipPosition.top -= eleDetails.baseBorderBottomWidth;\n        }\n    }else if(myPosition.hasOwnProperty('bottom') && regPer.test(myPosition.bottom)) {\n        let bottom = eleDetails.baseHeight * parseFloat(myPosition.bottom)/100;\n        tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseBorderBottomWidth + eleDetails.baseHeight + bottom;\n        if(regPerNegative.test(myPosition.bottom)) {\n            tipPosition.top -= eleDetails.baseBorderBottomWidth;\n        }\n    }else if(myPosition.hasOwnProperty('top') && regNum.test(myPosition.top)) {\n        tipPosition.top = eleDetails.baseTop - tipGroupHeight - parseFloat(myPosition.top);\n        if(regNumNegative.test(myPosition.top)) {\n            tipPosition.top = tipPosition.top + tipGroupHeight + eleDetails.baseBorderTopWidth;\n        }\n    }else if(myPosition.hasOwnProperty('top') && regPer.test(myPosition.top)) {\n        let top = eleDetails.baseHeight * parseFloat(myPosition.top)/100;\n        tipPosition.top = eleDetails.baseTop - top;\n        if(regPerNegative.test(myPosition.top)) {\n            tipPosition.top = tipPosition.top + eleDetails.baseBorderTopWidth;\n        }\n    }\n\n    if(myPosition.hasOwnProperty('right') && regNum.test(myPosition.right)) {\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseWidth + eleDetails.baseBorderRightWidth + parseFloat(myPosition.right);\n        if(regNumNegative.test(myPosition.right)) {\n            tipPosition.left = tipPosition.left - tipGroupWidth - eleDetails.baseBorderRightWidth;\n        }\n    }else if(myPosition.hasOwnProperty('right') && regPer.test(myPosition.right)) {\n        let right = eleDetails.baseWidth * parseFloat(myPosition.right)/100;\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseWidth + right;\n        if(regPerNegative.test(myPosition.right)) {\n            tipPosition.left = tipPosition.left - tipGroupWidth - eleDetails.baseBorderRightWidth;\n        }\n    }else if(myPosition.hasOwnProperty('left') && regNum.test(myPosition.left)) {\n        tipPosition.left = eleDetails.baseLeft - tipGroupWidth - parseFloat(myPosition.left);\n        if(regNumNegative.test(myPosition.left)) {\n            tipPosition.left = tipPosition.left + tipGroupWidth + eleDetails.baseBorderLeftWidth;\n        }\n    }else if(myPosition.hasOwnProperty('left') && regPer.test(myPosition.left)) {\n        let left = eleDetails.baseWidth * parseFloat(myPosition.left)/100;\n        tipPosition.left = eleDetails.baseLeft - tipGroupWidth - left;\n        if(regPerNegative.test(myPosition.left)) {\n            tipPosition.left = tipPosition.left + tipGroupWidth + eleDetails.baseBorderLeftWidth;\n        }\n    }\n\n    return tipPosition;\n}\n\n/**\n * 外围定位\n * 当百分比为正数时(从外部远离基准元素)，百分比基准是Tips元素\n * 当百分比为负数时(从内部远离基准元素)，百分比基准是基准元素\n * top, left, bottom, right 都是以基准元素的对应边框为准，且忽略边框厚度\n * 比如top，正数X%时，表示Tip 顶部高于基准元素的顶部 Tips高度*X%；负数-X%时，表示Tip 中心低于基准元素的顶部 基准元素高度*X%\n */\ntips.prototype.getPosStyleOuter = function(myPosition, calculateTip, tipPosition) {\n    let regNum = C.regNum;\n    let regNumNegative = C.regNumNegative;\n    let regPer = C.regPer;\n    let regPerNegative = C.regPerNegative;\n\n    let eleDetails = this.getElementDetails();\n\n    let tipGroupWidth = eleDetails.tipGroupWidth;\n    let tipGroupHeight = eleDetails.tipGroupHeight;\n    if(calculateTip === false) {\n        tipGroupWidth = 0;\n        tipGroupHeight = 0;\n    }\n\n    if(typeof myPosition == \"string\") {\n        let myPositionTmp = {};\n        switch(myPosition) {\n            case \"top-left\" :           //坐标在基准元素的左上角位置\n                // tipPosition.top = eleDetails.baseTop - tipGroupHeight * (100%)/100;\n                // tipPosition.left = eleDetails.baseLeft - tipGroupWidth * (100%)/100;\n                myPositionTmp.top = \"100%\";\n                myPositionTmp.left = \"-0%\";\n                break;\n            case \"top-center\" :         //坐标在基准元素的上中位置\n                myPositionTmp.top = \"100%\";\n                myPositionTmp.left = \"-50%\";\n                break;\n            case \"top-right\" :          //坐标在基准元素的右上角位置\n                myPositionTmp.top = \"100%\";\n                myPositionTmp.left = \"-100%\";\n                break;\n            case \"center-left\" :        //坐标在基准元素的左中位置\n                myPositionTmp.top = \"-50%\";\n                myPositionTmp.left = \"0\";\n                break;\n            case \"middle\" :             //坐标在基准元素的中间位置\n                myPositionTmp.top = \"-50%\";\n                myPositionTmp.left = \"-50%\";\n                break;\n            case \"center-right\" :       //坐标在基准元素的右中位置\n                myPositionTmp.top = \"-50%\";\n                myPositionTmp.right = \"100%\";\n                break;\n            case \"bottom-left\" :        //坐标在基准元素的左下角位置\n                myPositionTmp.bottom = \"100%\";\n                myPositionTmp.left = \"-0%\";\n                break;\n            case \"bottom-center\" :      //坐标在基准元素的下中位置\n                myPositionTmp.bottom = \"100%\";\n                myPositionTmp.left = \"-50%\";\n                break;\n            case \"bottom-right\" :       //坐标在基准元素的右下角位置\n                myPositionTmp.bottom = \"100%\";\n                myPositionTmp.left = \"-100%\";\n                break;\n            case \"left-top\" :       //坐标在基准元素的右下角位置\n                myPositionTmp.bottom = \"-100%\";\n                myPositionTmp.left = \"0\";\n                break;\n            case \"left-bottom\" :       //坐标在基准元素的右下角位置\n                myPositionTmp.top = \"-100%\";\n                myPositionTmp.left = \"0\";\n                break;\n            case \"right-top\" :       //坐标在基准元素的右下角位置\n                myPositionTmp.bottom = \"-100%\";\n                myPositionTmp.right = \"100%\";\n                break;\n            case \"right-bottom\" :       //坐标在基准元素的右下角位置\n                myPositionTmp.top = \"-100%\";\n                myPositionTmp.right = \"100%\";\n                break;\n            default :                   //默认坐标在基准元素的中间位置\n                myPositionTmp.top = \"100%\";\n                myPositionTmp.left = \"-0%\";\n                break;\n        }\n\n        myPosition = myPositionTmp;\n    }\n\n    // 非百分比区分正负主要是考虑到边框问题，忽略边框带来的影响\n    if(myPosition.hasOwnProperty('bottom') && regNum.test(myPosition.bottom)) {\n        if(!regNumNegative.test(myPosition.bottom)) {\n            tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseHeight + eleDetails.baseBorderBottomWidth + parseFloat(myPosition.bottom);\n        }else {\n            tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseHeight + parseFloat(myPosition.bottom);\n        }\n    }else if(myPosition.hasOwnProperty('bottom') && regPer.test(myPosition.bottom)) {\n        if(!regPerNegative.test(myPosition.bottom)) {\n            let bottom = tipGroupHeight - tipGroupHeight * parseFloat(myPosition.bottom)/100;\n            tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseBorderBottomWidth + eleDetails.baseHeight - bottom;\n        }else {\n            let bottom = (eleDetails.baseHeight - tipGroupHeight) * (-parseFloat(myPosition.bottom)/100);\n            tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + eleDetails.baseHeight - tipGroupHeight - bottom;\n        }\n    }else if(myPosition.hasOwnProperty('top') && regNum.test(myPosition.top)) {\n        if(!regNumNegative.test(myPosition.top)) {\n            tipPosition.top = eleDetails.baseTop - tipGroupHeight - parseFloat(myPosition.top);\n        }else {\n            tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth - tipGroupHeight - parseFloat(myPosition.top);\n        }\n    }else if(myPosition.hasOwnProperty('top') && regPer.test(myPosition.top)) {\n        if(!regPerNegative.test(myPosition.top)) {\n            let top = tipGroupHeight * parseFloat(myPosition.top)/100;\n            tipPosition.top = eleDetails.baseTop - top;\n        }else {\n            let top = (eleDetails.baseHeight - tipGroupHeight) * (-parseFloat(myPosition.top)/100);\n            tipPosition.top = eleDetails.baseTop + eleDetails.baseBorderTopWidth + top;\n        }\n    }\n\n    if(myPosition.hasOwnProperty('right') && regNum.test(myPosition.right)) {\n        tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseWidth + eleDetails.baseBorderRightWidth + parseFloat(myPosition.right);\n    }else if(myPosition.hasOwnProperty('right') && regPer.test(myPosition.right)) {\n        if(!regPerNegative.test(myPosition.right)) {\n            let right = tipGroupWidth - tipGroupWidth * parseFloat(myPosition.right)/100;\n            tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseBorderRightWidth + eleDetails.baseWidth - right;\n        }else {\n            let right = (eleDetails.baseWidth - tipGroupWidth) * (-parseFloat(myPosition.right)/100);\n            tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + eleDetails.baseWidth - tipGroupWidth - right;\n        }\n    }else if(myPosition.hasOwnProperty('left') && regNum.test(myPosition.left)) {\n        if(!regNumNegative.test(myPosition.left)) {\n            tipPosition.left = eleDetails.baseLeft - tipGroupWidth - parseFloat(myPosition.left);\n        }else {\n            tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth - tipGroupWidth - parseFloat(myPosition.left);\n        }\n    }else if(myPosition.hasOwnProperty('left') && regPer.test(myPosition.left)) {\n        if(!regPerNegative.test(myPosition.left)) {\n            let left = tipGroupWidth * parseFloat(myPosition.left)/100;\n            tipPosition.left = eleDetails.baseLeft - left;\n        }else {\n            let left = (eleDetails.baseWidth - tipGroupWidth) * (-parseFloat(myPosition.left)/100);\n            tipPosition.left = eleDetails.baseLeft + eleDetails.baseBorderLeftWidth + left;\n        }\n    }\n\n    return tipPosition;\n}\n\n/**\n * Offset 只支持px，用于微调基准元素与Tips 的相对定位\n * 计算定位得出的结果只含top和left，故offset只支持top和left\n * 比如上居中，此时Tips 顶部是紧贴着基准元素顶部的，设置offset.top = 10, 则Tips 顶部低于基准元素顶部10px\n */\ntips.prototype.setStylePositionOffset = function(tipPosition) {\n    let offset = this.options.offset;\n\n    if(!offset) return tipPosition;\n\n    let regNum = C.regNum;\n    if(offset.hasOwnProperty('top') && regNum.test(offset.top)) tipPosition.top += offset.top;\n    if(offset.hasOwnProperty('left') && regNum.test(offset.left)) tipPosition.left += offset.left;\n\n    return tipPosition;\n}\n\n/**\n * 已弃用。替代方案是根据Symbol 设置padding，利于动画执行\n * \n * 如果启动symbol，而symbol 不占Tips 宽度和高度。 则可根据symbol offset 微调父元素与Tips 的相对定位\n * Offset 只支持px\n * 计算定位得出的结果只含top和left，故offset只支持top和left\n * 比如上居中，此时Tips 顶部是紧贴着父元素顶部的，\n * 此时symbol 正常来说会高于Tips 上中部位, 如8px, 设置symbolOptions.offset.top = 8, 则Tips 顶部低于父元素顶部8px，Symbol紧贴父元素顶部\n */\ntips.prototype.setStyleSymbolOffset = function(tipPosition) {\n    if(!this.options.symbol) return tipPosition;\n    let regNum = C.regNum;\n\n    let tmpOffset = {\n        top: null,\n        left: null,\n    };\n\n    let symbolSize = this.getSymbolSize();\n\n    let symbolPosition = this.options.symbolOptions.position || this.mapPositionToSymbolPosition(this.options.position);\n    if(symbolPosition && typeof symbolPosition == 'string') {\n        switch(symbolPosition) {\n            case \"top-left\" :           //坐标在Tips 的左上角位置\n                tmpOffset.top = symbolSize.height;\n                break;\n            case \"top-center\" :         //坐标在Tips 的上中位置\n                tmpOffset.top = symbolSize.height;\n                break;\n            case \"top-right\" :          //坐标在Tips 的右上角位置\n                tmpOffset.top = symbolSize.height;\n                break;\n            case \"center-left\" :        //坐标在Tips 的左中位置\n                tmpOffset.left = symbolSize.width;\n                break;\n            case \"middle\" :             //坐标在Tips 的中间位置\n                // tmpOffset.left = symbolSize.width;\n                break;\n            case \"center-right\" :       //坐标在Tips 的右中位置\n                tmpOffset.left = 0 - symbolSize.width;\n                break;\n            case \"bottom-left\" :        //坐标在Tips 的左下角位置\n                tmpOffset.top = 0 - symbolSize.height;\n                break;\n            case \"bottom-center\" :      //坐标在Tips 的下中位置\n                tmpOffset.top = 0 - symbolSize.height;\n                break;\n            case \"bottom-right\" :       //坐标在Tips 的右下角位置\n                tmpOffset.top = 0 - symbolSize.height;\n                break;\n            case \"left-top\" :               //坐标在Tips 的上左角位置\n                tmpOffset.left = symbolSize.width;\n                break;\n            case \"left-bottom\" :                //坐标在Tips 的下左角位置\n                tmpOffset.left = symbolSize.width;\n                break;\n            case \"right-top\" :              //坐标在Tips 的上右角位置\n                tmpOffset.left = 0 - symbolSize.width;\n                break;\n            case \"right-bottom\" :               //坐标在Tips 的下右角位置\n                tmpOffset.left = 0 - symbolSize.width;\n                break;\n            default :                   //默认坐标在Tips 的中间位置\n                break;\n        }\n    }\n\n    this.writeLog('info', 'setStyleSymbolOffset: ', symbolSize, symbolPosition, tmpOffset);\n\n    // offset 以symbolOptions.offset 为准，tmpOffset 为辅，内外部定位规则一样\n    let offset = C.extend({}, this.options.symbolOptions.offset, tmpOffset);\n    // 当为外部定位时，需要反转\n    // if(this.options.direction == 'outer' || this.options.direction == 'outside') {\n    //     if(offset.hasOwnProperty('top') && regNum.test(offset.top)) offset.top = 0 - offset.top;\n    //     if(offset.hasOwnProperty('left') && regNum.test(offset.left)) offset.left = 0 - offset.left;\n    // }\n\n    this.writeLog('info', 'setStyleSymbolOffset: ', symbolSize, offset);\n\n    if(offset.top || offset.left) {\n        if(offset.hasOwnProperty('top') && regNum.test(offset.top)) tipPosition.top += offset.top;\n        if(offset.hasOwnProperty('left') && regNum.test(offset.left)) tipPosition.left += offset.left;\n    }\n\n    return tipPosition;\n}\n\n//根据不同的symbol 类型获取不同的Size，用于定位补足\ntips.prototype.getSymbolSize = function() {\n    let symbol = \"triangle\";\n    if(typeof this.options.symbol == 'string') symbol = this.options.symbol;\n\n    let getSymbolSizeMethod = \"getSymbolSize\" + symbol.slice(0, 1).toUpperCase() + symbol.slice(1);\n    return this[getSymbolSizeMethod]();\n}\n\n//获取Triangle Size，用于定位补足\ntips.prototype.getSymbolSizeTriangle = function() {\n    let $symbol = this.backup._symbolElm;\n    let symbolSize = {width: 0, height: 0};\n\n    if(!$symbol) return symbolSize;\n    //Triangle 的四个边框都一样\n    let borderWidth = parseFloat(C.css($symbol, \"border-top-width\"));\n    symbolSize.width = borderWidth;\n    symbolSize.height = borderWidth;\n\n    return symbolSize;\n}\n\ntips.prototype.getPosition = function(myPosition) {\n    let positionClass = this.getPositionClass(myPosition);\n    let positionStyle = this.getPositionStyle(myPosition);\n    let tipPosition = {\n        class: positionClass,\n        style: positionStyle,\n    };\n\n    return tipPosition;\n}\n\n//设置浮动参数。支持用户自定义。\ntips.prototype.setFloatOptions = function(customFloatOptions) {\n    //窗口发生变化时需要重新定义float\n    //若不是首次设置，则还原当前状态\n    let backupfloatOptions = {};\n    if(this.floatOptions) {\n        backupfloatOptions.status = this.floatOptions.status;\n        backupfloatOptions.floatId = this.floatOptions.floatId;\n    };\n\n    //用户自定义\n    if(this.options.float.customFloatOptions) customFloatOptions = this.options.float.customFloatOptions;\n\n    let floatOptions = C.extend({}, tips.floatOptions, customFloatOptions, backupfloatOptions);\n\n    let eleDetails = this.getElementDetails();\n\n    //设置最大最小值，一般最小值0，最大值视情况而定，若是一般情况（px）则为元素的最大阈值，如是百分比，则为100%\n    floatOptions.xMinThreshold = !C.isEmptyNum(floatOptions.xMinThreshold)? floatOptions.xMinThreshold : 0;\n    floatOptions.xMaxThreshold = !C.isEmptyNum(floatOptions.xMaxThreshold)? floatOptions.xMaxThreshold : eleDetails.leftThreshold;\n    floatOptions.yMinThreshold = !C.isEmptyNum(floatOptions.yMinThreshold)? floatOptions.yMinThreshold : 0;\n    floatOptions.yMaxThreshold = !C.isEmptyNum(floatOptions.yMaxThreshold)? floatOptions.yMaxThreshold : eleDetails.topThreshold;\n\n    floatOptions.xOffset = (floatOptions.xMaxThreshold - floatOptions.xMinThreshold) * floatOptions.xOffsetLen;\n    floatOptions.yOffset = (floatOptions.yMaxThreshold- floatOptions.yMinThreshold) * floatOptions.yOffsetLen;\n\n    if(floatOptions.hasOwnProperty('offsetType') && floatOptions.offsetType === '%') {\n        floatOptions.xOffset = floatOptions.xOffsetLen;  \n        floatOptions.yOffset = floatOptions.yOffsetLen;\n    }\n\n    this.floatOptions = floatOptions;\n\n    return this.floatOptions;\n}\n\n//当需要重新设置float，如窗口，基准元素发生改变，若不是首次设置，则还原当前状态\ntips.prototype.getfloatStatus = function(customFloatStatus) {\n    if(this.options.float.customFloatStatus) {\n        customFloatStatus = this.options.float.customFloatStatus;\n    }else if(!customFloatStatus){\n        customFloatStatus = {\n            top: tips.floatOptions.topStart,\n            left: tips.floatOptions.leftStart,\n        }\n    }\n    for(let key in customFloatStatus) {\n        if(this.backup._floatStatus.hasOwnProperty(key)) {\n            customFloatStatus[key] = this.backup._floatStatus[key];\n        }\n    }\n\n    return customFloatStatus;\n}\n\n/**\n * 设置浮动定位的状态，触发Tips 重新定位，实现浮动的效果\n */\ntips.prototype.setFloatStatus = function(floatStatus, floatOptions) {\n    if(floatStatus.top > floatOptions.yMaxThreshold) floatStatus.top = floatOptions.yMaxThreshold;\n    if(floatStatus.top < floatOptions.yMinThreshold) floatStatus.top = floatOptions.yMinThreshold;\n    if(floatStatus.left > floatOptions.xMaxThreshold) floatStatus.left = floatOptions.xMaxThreshold;\n    if(floatStatus.left < floatOptions.xMinThreshold) floatStatus.left = floatOptions.xMinThreshold;\n\n    for(let key in floatStatus) {\n        this.backup._floatStatus[key] = floatStatus[key];\n    }\n\n    let offsetType = floatOptions.hasOwnProperty('offsetType')? floatOptions.offsetType : '';\n\n    //请务必设置floatPosition，否则不生效\n    this.monitor.floatPosition = {\n        top: floatStatus.top + offsetType,\n        left: floatStatus.left + offsetType,\n    }\n}\n\n//默认浮动方式。沿着基准元素左上角到右下角直线浮动\n//用户自定义浮动方法，可参考该方法。\ntips.prototype.floatTypeDefault = function() {\n    let _this = this;\n\n    let customFloatOptions = {\n        status: true,\n        xOffsetLen: 0.0005,\n        yOffsetLen: 0.0005,\n        delay: 1,\n    };\n\n    let customFloatStatus = {\n        top: 0,\n        left: 0,\n    };\n\n    let floatOptions = this.setFloatOptions(customFloatOptions);\n    let floatStatus = this.getfloatStatus(customFloatStatus);\n\n    if(floatOptions.floatId) clearInterval(floatOptions.floatId);\n    floatOptions.floatId = setInterval(function(){\n        if((floatStatus.top >= floatOptions.yMaxThreshold && floatOptions.status) || (floatStatus.top <= floatOptions.yMinThreshold && !floatOptions.status)) {\n            floatOptions.status = !floatOptions.status;\n        }\n\n        if(floatOptions.status) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }\n\n        _this.setFloatStatus(floatStatus, floatOptions);\n    }, floatOptions.delay);\n};\n\n//X 浮动\n//浮动方向是 左上角->右下角->右上角->左下角->左上角...\ntips.prototype.floatTypeX = function() {\n    let _this = this;\n\n    let customFloatOptions = {\n        status: 1,\n        offsetType: '%',\n        xMinThreshold: 0,\n        xMaxThreshold: 100,\n        xOffsetLen: 0.01,\n        yMinThreshold: 0,\n        yMaxThreshold: 100,\n        yOffsetLen: 0.01,\n        delay: 1,\n    };\n    \n    let customFloatStatus = {\n        top: 0,\n        left: 0,\n    };\n\n    let floatOptions = this.setFloatOptions(customFloatOptions);\n    let floatStatus = this.getfloatStatus(customFloatStatus);\n\n    if(floatOptions.floatId) clearInterval(floatOptions.floatId);\n    floatOptions.floatId = setInterval(function(){\n        if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n            floatOptions.status = 1;\n        }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n            floatOptions.status = 2;\n        }else if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n            floatOptions.status = 3;\n        }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n            floatOptions.status = 4;\n        }\n\n        if(floatOptions.status == 1) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else if(floatOptions.status == 2) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }else if(floatOptions.status == 3) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }else if(floatOptions.status == 4) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }\n\n        _this.setFloatStatus(floatStatus, floatOptions);\n    }, floatOptions.delay);\n};\n\n//方形浮动\n//浮动方向是 左上角->右上角->右下角->左下角->左上角...\ntips.prototype.floatTypeSquare =  function() {\n    let _this = this;\n\n    let customFloatOptions = {\n        status: 1,\n        offsetType: '%',\n        xMinThreshold: 0,\n        xMaxThreshold: 100,\n        xOffsetLen: 0.01,\n        yMinThreshold: 0,\n        yMaxThreshold: 100,\n        yOffsetLen: 0.01,\n        delay: 1,\n    };\n\n    let customFloatStatus = {\n        top: 0,\n        left: 0,\n    };\n\n    let floatOptions = this.setFloatOptions(customFloatOptions);\n    let floatStatus = this.getfloatStatus(customFloatStatus);\n\n    if(floatOptions.floatId) clearInterval(floatOptions.floatId);\n    floatOptions.floatId = setInterval(function(){\n        if(floatOptions.yMinThreshold != floatOptions.yMaxThreshold && floatOptions.xMinThreshold != floatOptions.xMaxThreshold){\n            if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n                floatOptions.status = 1;\n            }else if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n                floatOptions.status = 2;\n            }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n                floatOptions.status = 3;\n            }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n                floatOptions.status = 4;\n            }\n        }\n\n        if(floatOptions.yMinThreshold == floatOptions.yMaxThreshold && floatOptions.xMinThreshold != floatOptions.xMaxThreshold){\n            if(floatStatus.left <= floatOptions.xMinThreshold) {\n                floatOptions.status = 5;\n            }else if(floatStatus.left >= floatOptions.xMaxThreshold) {\n                floatOptions.status = 6;\n            }\n        }\n\n        if(floatOptions.yMinThreshold != floatOptions.yMaxThreshold && floatOptions.xMinThreshold == floatOptions.xMaxThreshold){\n            if(floatStatus.top <= floatOptions.yMinThreshold) {\n                floatOptions.status = 7;\n            }else if(floatStatus.top >= floatOptions.yMaxThreshold) {\n                floatOptions.status = 8;\n            }\n        }\n\n        if(floatOptions.status == 1) {\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else if(floatOptions.status == 2) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n        }else if(floatOptions.status == 3) {\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }else if(floatOptions.status == 4) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }else if(floatOptions.status == 5) {\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else if(floatOptions.status == 6) {\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }else if(floatOptions.status == 7) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n        }else if(floatOptions.status == 8) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }\n\n        _this.setFloatStatus(floatStatus, floatOptions);\n    }, floatOptions.delay);\n};\n\ntips.prototype.setFloatType = function() {\n    let type = this.options.float.type;\n    let floatFun = 'floatType' + type.slice(0, 1).toUpperCase() + type.slice(1);\n    if(this[floatFun]) {\n        this[floatFun]();\n    }else {\n        this.floatTypeDefault();\n    }\n};\n\ntips.prototype.setFloatEvents = function() {\n    let _this = this;\n    let $tip = _this.backup._tipElm;\n    let floatFlag = 0;\n\n    let hoverIn = function() {\n        if(_this.floatOptions.floatId) clearInterval(_this.floatOptions.floatId);\n    }\n    let hoverOut = function() {\n        _this.setFloatPosition(++floatFlag);\n    }\n    \n    $tip.onmouseenter = hoverIn;\n    $tip.onmouseleave = hoverOut;\n};\n\ntips.prototype.setFloatPosition = function(floatFlag = 0) {\n    this.options.events.beforeFloated.call(this, floatFlag);      //Tips 浮动之前 触发\n\n    let _this = this;\n    let $tip = _this.backup._tipElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $pElem = _this.backup._baseElm;\n\n    C.css($tipGroup, {display: 'none'});\n    let tipPosition = _this.getPosition({});\n    C.addClass($tipGroup, tipPosition.class.tipClass);\n\n    Object.defineProperty(_this.monitor, 'floatPosition', {\n        get:function(){\n            return floatPosition;\n        },\n        set:function(newValue){\n            let floatPosition = newValue;\n            let tipPosition = _this.getPosition(floatPosition);\n            C.addCss($tipGroup, tipPosition.style);\n            C.addCss($tipGroup, {display: 'block'});\n        }\n    });\n\n    if(typeof _this.options.float.customFloatFuntion === \"function\") {\n        _this.options.float.customFloatFuntion.call(_this);\n    }else {\n        _this.setFloatType();\n    }\n\n    if(floatFlag === 0) _this.setFloatEvents();\n\n    this.options.events.floated.call(this, floatFlag);      //Tips 浮动之后 触发\n};\n\n/**\n * 设置浮动参数。支持用户自定义。 支持的参数有，参考 tips.floatOptions\n * topStart: 0,                //浮动起始位置 Top\n * leftStart: 0,               //浮动起始位置 Left\n * status: true,               //浮动状态，一般用于转折点改变方向趋势\n * offsetType: '',             //每次改变状态量的类型，px 或 百分比，默认px\n * xMinThreshold: 0,           //x轴相对于基准元素的最小偏差值\n * xMaxThreshold: '',          //x轴相对于基准元素的最大偏差值\n * xOffsetLen: 1,              //x轴一次的偏差量\n * yMinThreshold: 0,           //y轴相对于基准元素的最小偏差值\n * yMaxThreshold: '',          //y轴相对于基准元素的最大偏差值\n * yOffsetLen: 1,              //y轴一次的偏差量\n * delay: 1,                   //浮动位置的时间间隔，单位毫秒\n * \n * @param    Object                 customFloatOptions 函数内自定义浮动参数，优先级低于用户自定义浮动参数\n */\ntips.prototype.setFloatTranslateOptions = function(customFloatOptions) {\n    //窗口发生变化时需要重新定义float\n    //若不是首次设置，则还原当前状态\n    let backupfloatOptions = {};\n    //注意 this.floatOptions 和 tips.floatOptions 不同\n    //前者是当前实例的浮动参数， 后者是默认参数\n    if(this.floatOptions) {\n        backupfloatOptions.status = this.floatOptions.status;       //当前状态，一般是转折点状态\n        backupfloatOptions.floatId = this.floatOptions.floatId;     //每个浮动都是依靠setInterval 实现的，此为其id\n    };\n\n    //用户自定义浮动参数，优先级高于函数内自定义浮动参数\n    if(this.options.float.customFloatOptions) customFloatOptions = this.options.float.customFloatOptions;\n\n    let floatOptions = C.extend({}, tips.floatOptions, customFloatOptions, backupfloatOptions);\n\n    let eleDetails = this.getElementDetails();\n\n    floatOptions.xMinThreshold = !C.isEmptyNum(floatOptions.xMinThreshold)? floatOptions.xMinThreshold : 0;\n    floatOptions.yMinThreshold = !C.isEmptyNum(floatOptions.yMinThreshold)? floatOptions.yMinThreshold : 0;\n\n    //设置最大最小值，一般最小值0，最大值视情况而定，若是一般情况（px）则为元素的最大阈值，如是百分比，则为100%\n    if(floatOptions.hasOwnProperty('offsetType') && floatOptions.offsetType === '%') {\n        floatOptions.xMaxThreshold = !C.isEmptyNum(floatOptions.xMaxThreshold)? floatOptions.xMaxThreshold : 100;\n        floatOptions.yMaxThreshold = !C.isEmptyNum(floatOptions.yMaxThreshold)? floatOptions.yMaxThreshold : 100;\n        floatOptions.xOffset = floatOptions.xOffsetLen;\n        floatOptions.yOffset = floatOptions.yOffsetLen;\n    }else {\n        floatOptions.xMaxThreshold = !C.isEmptyNum(floatOptions.xMaxThreshold)? floatOptions.xMaxThreshold : eleDetails.leftThreshold;\n        floatOptions.yMaxThreshold = !C.isEmptyNum(floatOptions.yMaxThreshold)? floatOptions.yMaxThreshold : eleDetails.topThreshold;\n        floatOptions.xOffset = (floatOptions.xMaxThreshold - floatOptions.xMinThreshold) * floatOptions.xOffsetLen;\n        floatOptions.yOffset = (floatOptions.yMaxThreshold- floatOptions.yMinThreshold) * floatOptions.yOffsetLen;\n    }\n\n    this.floatOptions = floatOptions;\n\n    return this.floatOptions;\n}\n\n//当需要重新设置float，如窗口，基准元素发生改变，若不是首次设置，则还原当前状态\ntips.prototype.getfloatTranslateStatus = function(customFloatStatus) {\n    if(this.options.float.customFloatStatus) {\n        customFloatStatus = this.options.float.customFloatStatus;\n    }else if(!customFloatStatus){\n        customFloatStatus = {\n            top: tips.floatOptions.topStart,\n            left: tips.floatOptions.leftStart,\n        }\n    }\n\n    //从备份的状态中恢复\n    for(let key in customFloatStatus) {\n        if(this.backup._floatStatus.hasOwnProperty(key)) {\n            customFloatStatus[key] = this.backup._floatStatus[key];\n        }else {\n            this.backup._floatStatus[key] = customFloatStatus[key];\n        }\n    }\n\n    return customFloatStatus;\n}\n\n/**\n * 设置当前translate 状态\n * @DateTime 2020-05-24T21:01:32+0800\n */\ntips.prototype.setFloatTranslateStatus = function(floatStatus, floatOptions) {\n    //状态不能超出临界值，一般目的是为了保证不超出基准元素(即临界值不超出基准元素)\n    if(floatStatus.top > floatOptions.yMaxThreshold) floatStatus.top = floatOptions.yMaxThreshold;\n    if(floatStatus.top < floatOptions.yMinThreshold) floatStatus.top = floatOptions.yMinThreshold;\n    if(floatStatus.left > floatOptions.xMaxThreshold) floatStatus.left = floatOptions.xMaxThreshold;\n    if(floatStatus.left < floatOptions.xMinThreshold) floatStatus.left = floatOptions.xMinThreshold;\n\n    for(let key in floatStatus) {\n        this.backup._floatStatus[key] = floatStatus[key];\n    }\n\n    //一般是px 或者 百分比\n    let offsetType = floatOptions.hasOwnProperty('offsetType')? floatOptions.offsetType : '';\n\n    //请务必设置floatTranslate，否则不生效\n    this.monitor.floatTranslate = {\n        top: floatStatus.top + offsetType,\n        left: floatStatus.left + offsetType,\n    }\n}\n\n//默认浮动方式。沿着基准元素左上角到右下角直线浮动\n//用户自定义浮动方法，可参考该方法。\ntips.prototype.floatTranslateTypeDefault = function() {\n    let _this = this;\n\n    //函数内自定义的浮动参数，参考 tips.floatOptions\n    //优先级低于用户自定义浮动参数 this.options.float.customFloatOptions\n    let customFloatOptions = {\n        status: true,\n        xOffsetLen: 0.0005,\n        yOffsetLen: 0.0005,\n        delay: 1,\n    };\n\n    //浮动起始状态，如不设置，默认值 tips.floatOptions.topStart 和 tips.floatOptions.leftStart\n    //优先级低于 this.options.float.customFloatStatus\n    //首次设置浮动时，this.options.float.customFloatStatus 不存在，以后每次浮动都会记录当前浮动状态。 \n    //当浏览器窗口大小发生改变时，会重新设置浮动。 此时this.options.float.customFloatStatus已存在，则以其为准，忽略 customFloatStatus\n    let customFloatStatus = {\n        top: 0,\n        left: 0,\n    };\n\n    //用户自定义浮动函数时，注意要执行这两个函数\n    let floatOptions = this.setFloatTranslateOptions(customFloatOptions);\n    let floatStatus = this.getfloatTranslateStatus(customFloatStatus);\n\n    this.writeLog('info', 'floatOptions: ', floatOptions);\n\n    //首次设置浮动时，添加间歇调用，id 保存为 floatId\n    //当浏览器窗口大小发生改变时，会重新设置浮动。 需要清空floatId并重新设置间歇调用\n    //间歇调用函数依赖于floatOptions 和 floatStatus\n    if(floatOptions.floatId) clearInterval(floatOptions.floatId);\n    floatOptions.floatId = setInterval(function(){\n        //浮动状态top大于y轴临界值，表示已到达基准元素底部，反过来则表示到达基准元素顶部\n        if((floatStatus.top >= floatOptions.yMaxThreshold && floatOptions.status) || (floatStatus.top <= floatOptions.yMinThreshold && !floatOptions.status)) {\n            floatOptions.status = !floatOptions.status;\n        }\n\n        if(floatOptions.status) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }\n\n        //浮动最重要的一步，设置浮动状态，将会触发浮动定位的改变\n        _this.setFloatTranslateStatus(floatStatus, floatOptions);\n    }, floatOptions.delay);\n};\n\n//X 浮动\n//浮动方向是 左上角->右下角->右上角->左下角->左上角...\ntips.prototype.floatTranslateTypeX = function() {\n    let _this = this;\n\n    let customFloatOptions = {\n        status: 1,\n        offsetType: '%',\n        xMinThreshold: 0,\n        xMaxThreshold: 100,\n        xOffsetLen: 0.01,\n        yMinThreshold: 0,\n        yMaxThreshold: 100,\n        yOffsetLen: 0.01,\n        delay: 1,\n    };\n    \n    let customFloatStatus = {\n        top: 0,\n        left: 0,\n    };\n\n    let floatOptions = this.setFloatTranslateOptions(customFloatOptions);\n    let floatStatus = this.getfloatTranslateStatus(customFloatStatus);\n\n    if(floatOptions.floatId) clearInterval(floatOptions.floatId);\n    floatOptions.floatId = setInterval(function(){\n        if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n            floatOptions.status = 1;\n        }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n            floatOptions.status = 2;\n        }else if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n            floatOptions.status = 3;\n        }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n            floatOptions.status = 4;\n        }\n\n        if(floatOptions.status == 1) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else if(floatOptions.status == 2) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }else if(floatOptions.status == 3) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }else if(floatOptions.status == 4) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }\n\n        _this.setFloatTranslateStatus(floatStatus, floatOptions);\n    }, floatOptions.delay);\n};\n\n//方形浮动\n//浮动方向是 左上角->右上角->右下角->左下角->左上角...\ntips.prototype.floatTranslateTypeSquare =  function() {\n    let _this = this;\n\n    let customFloatOptions = {\n        status: 1,\n        offsetType: '%',\n        xMinThreshold: 0,\n        xMaxThreshold: 100,\n        xOffsetLen: 0.01,\n        yMinThreshold: 0,\n        yMaxThreshold: 100,\n        yOffsetLen: 0.01,\n        delay: 1,\n    };\n\n    let customFloatStatus = {\n        top: 0,\n        left: 0,\n    };\n\n    let floatOptions = this.setFloatTranslateOptions(customFloatOptions);\n    let floatStatus = this.getfloatTranslateStatus(customFloatStatus);\n\n    if(floatOptions.floatId) clearInterval(floatOptions.floatId);\n    floatOptions.floatId = setInterval(function(){\n        if(floatOptions.yMinThreshold != floatOptions.yMaxThreshold && floatOptions.xMinThreshold != floatOptions.xMaxThreshold){\n            if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n                floatOptions.status = 1;\n            }else if(floatStatus.top <= floatOptions.yMinThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n                floatOptions.status = 2;\n            }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left >= floatOptions.xMaxThreshold) {\n                floatOptions.status = 3;\n            }else if(floatStatus.top >= floatOptions.yMaxThreshold && floatStatus.left <= floatOptions.xMinThreshold) {\n                floatOptions.status = 4;\n            }\n        }\n\n        if(floatOptions.yMinThreshold == floatOptions.yMaxThreshold && floatOptions.xMinThreshold != floatOptions.xMaxThreshold){\n            if(floatStatus.left <= floatOptions.xMinThreshold) {\n                floatOptions.status = 5;\n            }else if(floatStatus.left >= floatOptions.xMaxThreshold) {\n                floatOptions.status = 6;\n            }\n        }\n\n        if(floatOptions.yMinThreshold != floatOptions.yMaxThreshold && floatOptions.xMinThreshold == floatOptions.xMaxThreshold){\n            if(floatStatus.top <= floatOptions.yMinThreshold) {\n                floatOptions.status = 7;\n            }else if(floatStatus.top >= floatOptions.yMaxThreshold) {\n                floatOptions.status = 8;\n            }\n        }\n\n        if(floatOptions.status == 1) {\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else if(floatOptions.status == 2) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n        }else if(floatOptions.status == 3) {\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }else if(floatOptions.status == 4) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }else if(floatOptions.status == 5) {\n            floatStatus.left = floatStatus.left + floatOptions.xOffset;\n        }else if(floatOptions.status == 6) {\n            floatStatus.left = floatStatus.left - floatOptions.xOffset;\n        }else if(floatOptions.status == 7) {\n            floatStatus.top = floatStatus.top + floatOptions.yOffset;\n        }else if(floatOptions.status == 8) {\n            floatStatus.top = floatStatus.top - floatOptions.yOffset;\n        }\n\n        _this.setFloatTranslateStatus(floatStatus, floatOptions);\n    }, floatOptions.delay);\n};\n\n/**\n * 设置浮动的起始点\n * 通过间歇改变tipGroup元素translate达到浮动的效果\n */\ntips.prototype.setfloatTranslateStart = function() {\n    let floatOptions = this.floatOptions;\n    let offsetType = floatOptions.hasOwnProperty('offsetType')? floatOptions.offsetType : '';\n    let positionStart = {\n        top: floatOptions.topStart + offsetType,\n        left: floatOptions.leftStart + offsetType,\n    };\n\n    let $tipGroup = this.backup._tipGroupElm;\n    let tipPositionStart = this.getPosition(positionStart);\n    C.addClass($tipGroup, tipPositionStart.class.tipClass);\n    C.addCss($tipGroup, tipPositionStart.style);\n}\n\n/**\n * 设置浮动类型，默认浮动方式是左上角->右下角\n */\ntips.prototype.setFloatTranslateType = function() {\n    let type = this.options.float.type;\n    let floatFun = 'floatTranslateType' + type.slice(0, 1).toUpperCase() + type.slice(1);\n    if(this[floatFun]) {\n        this[floatFun]();\n    }else {\n        this.floatTypeTranslateDefault();\n    }\n};\n\n/**\n * 浮动回调函数\n * 鼠标悬停在Tips 上时，停止浮动\n * 鼠标从Tips移开，继续浮动\n */\ntips.prototype.setFloatTranslateEvents = function() {\n    let _this = this;\n    let $tip = _this.backup._tipElm;\n    let floatFlag = 0;\n\n    let hoverIn = function() {\n        if(_this.floatOptions.floatId) clearInterval(_this.floatOptions.floatId);\n    }\n    let hoverOut = function() {\n        _this.setFloatTranslate(++floatFlag);\n    }\n    \n    $tip.onmouseenter = hoverIn;\n    $tip.onmouseleave = hoverOut;\n};\n\n/**\n * 计算Tips 位置转变量，支持px和百分比\n */\ntips.prototype.getTranslate = function(myTranslate, calculateTip) {\n    let eleDetails = this.getElementDetails();\n\n    let tipGroupWidth = eleDetails.tipGroupWidth;\n    let tipGroupHeight = eleDetails.tipGroupHeight;\n    if(calculateTip === false) {\n        tipGroupWidth = 0;\n        tipGroupHeight = 0;\n    }\n\n    let tipTranslate = {\n        top: \"\",\n        left: \"\",\n    };\n\n    if(this.floatOptions.hasOwnProperty('offsetType') && this.floatOptions.offsetType === '%') {\n        tipTranslate.top = (eleDetails.baseHeight - tipGroupHeight) * parseFloat(myTranslate.top)/100;\n        tipTranslate.left = (eleDetails.baseWidth - tipGroupWidth) * parseFloat(myTranslate.left)/100;\n    }else {\n        tipTranslate.top = parseFloat(myTranslate.top);\n        tipTranslate.left = parseFloat(myTranslate.left);\n    }\n\n    tipTranslate.top = tipTranslate.top.toFixed(4) + \"px\";\n    tipTranslate.left = tipTranslate.left.toFixed(4) + \"px\";\n\n    return tipTranslate;\n};\n\n/**\n * translate 浮动入口函数。\n */\ntips.prototype.setFloatTranslate = function(floatFlag = 0) {\n    this.options.events.beforeFloated.call(this, floatFlag);      //Tips 浮动之前 触发\n\n    let _this = this;\n    let $tip = _this.backup._tipElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $pElem = _this.backup._baseElm;\n\n    C.css($tipGroup, {display: 'none'});\n\n    let lastValue = null;\n    let lastTipTranslate = null;\n\n    let compare = function(lastValue, newValue) {\n        // _this.writeLog('info', '*** Compare Value: ', lastValue, newValue);\n\n        if(!lastValue) {\n            _this.writeLog('info', 'No last value');\n            return;\n        }\n\n        lastValue = C.extend({}, lastValue);\n        newValue = C.extend({}, newValue);\n\n        let type = \"value\";\n        if(C.isString(lastValue.left)) {\n            type = \"translate\";\n            lastValue.left = parseFloat(lastValue.left);\n            lastValue.top = parseFloat(lastValue.top);\n            newValue.left = parseFloat(newValue.left);\n            newValue.top = parseFloat(newValue.top);\n        }\n\n        let leftFlag = '?';\n        if(newValue.left > lastValue.left) leftFlag = '>';\n        else if(newValue.left == lastValue.left) leftFlag = '=';\n        else if(newValue.left < lastValue.left) leftFlag = '<';\n\n        let topFlag = '?';\n        if(newValue.top > lastValue.top) topFlag = '>';\n        else if(newValue.top == lastValue.top) topFlag = '=';\n        else if(newValue.top < lastValue.top) topFlag = '<';\n\n        // _this.writeLog('info', 'New %s Left : Old %s Left ? ', type, type, leftFlag);\n        // _this.writeLog('info', 'New %s Top  : Old %s Top  ? ', type, type, leftFlag);\n\n        return {\n            leftFlag: leftFlag,\n            topFlag: topFlag,\n        }\n    }\n\n    let compareResult = function(valueResult, translateResult) {\n        if(!valueResult) return true;\n\n        let result = true;\n\n        if(valueResult.leftFlag != translateResult.leftFlag) {\n            _this.writeLog('error', 'Translate Left Error! ', valueResult.leftFlag, translateResult.leftFlag);\n            result = false;\n        }\n\n        if(valueResult.topFlag != translateResult.topFlag) {\n            _this.writeLog('error', 'Translate Top Error! ', valueResult.topFlag, translateResult.topFlag);\n            result = false;\n        }\n\n        return result;\n    }\n\n    //给this.monitor 添加新属性 floatTranslate\n    //当 floatTranslate改变时，设置 tipGroup 的 translate，达到浮动的效果\n    Object.defineProperty(_this.monitor, 'floatTranslate', {\n        get:function(){\n            return floatTranslate;\n        },\n        set:function(newValue){\n            let floatTranslate = newValue;\n            let tipTranslate = _this.getTranslate(floatTranslate);\n\n            // 想调试的话就取消注释\n            // let result = compareResult(compare(lastValue, newValue), compare(lastTipTranslate, tipTranslate));\n            // if(!result) {\n            //     _this.writeLog('info', '--- Last Value: ', lastValue, lastTipTranslate);\n            //     _this.writeLog('info', '+++ New  Value: ', newValue, tipTranslate);\n            // }\n\n            let translate = {\n                display: 'block',\n                transform: 'translate('+ tipTranslate.left + ',' + tipTranslate.top + ')',\n            };\n\n            C.addCss($tipGroup, translate);\n\n            lastValue = newValue;\n            lastTipTranslate = tipTranslate;\n        }\n    });\n\n    if(typeof _this.options.float.customFloatFuntion === \"function\") {\n        _this.options.float.customFloatFuntion.call(_this);\n    }else {\n        _this.setFloatTranslateType();\n    }\n\n    this.setfloatTranslateStart();\n\n    if(floatFlag === 0) _this.setFloatTranslateEvents();\n\n    this.options.events.floated.call(this, floatFlag);      //Tips 浮动之后 触发\n};\n\n/**\n * 设置Tips Group 定位\n * 包括固定定位和浮动定位。\n * Float 和 Translate 都是浮动定位，只用使用的方法不同\n */\ntips.prototype.setTipsPosition = function() {\n    let $tip = this.backup._tipElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $pElem = this.backup._baseElm;\n\n    if(this.options.position == 'float') {\n        this.setFloatPosition();\n    }else if(this.options.position == 'translate') {\n        this.setFloatTranslate();\n    }else {\n        let tipPosition = this.getPosition(this.options.position);\n        if(this.isBodyElement()) {\n            C.addClass($tipGroup, tipPosition.class.tipClass);\n            this.setClassOffset();\n        }else {\n            $tipGroup.style.cssText = '';\n            C.addCss($tipGroup, tipPosition.style);\n        }\n    }\n};\n\ntips.prototype.setBgPosition = function() {\n    if(!this.options.background || !this.backup._backgroundElem) return false;\n    let $bg = this.backup._backgroundElem;\n\n    if(this.isBodyElement()) {\n        let positionClass = this.getPositionClass(this.options.position);\n        C.addClass($bg, positionClass.bgClass);\n    }else {\n        let eleDetails = this.getElementDetails();\n        let bgCss = C.extend({}, eleDetails.basePosition, {\n            width: eleDetails.baseOuterWidth,\n            height: eleDetails.baseOuterHeight\n        }, {\"border-radius\": eleDetails.baseBorderRadius});\n\n        C.addCss($bg, bgCss);\n    }\n};\n\n//初始化Tips位置，目的在于可以获得Tips 的真实宽度高度\ntips.prototype.setInitPosition = function() {\n    let $tipGroup = this.backup._tipGroupElm;\n    C.addClass($tipGroup, 'ohoTip-init');\n}\n\n//初始化Tips位置后必须去除\ntips.prototype.unsetInitPosition = function() {\n    let $tipGroup = this.backup._tipGroupElm;\n    C.removeClass($tipGroup, 'ohoTip-init');\n}\n\ntips.prototype.setPosition = function() {\n    this.setTipsPosition();\n    this.setBgPosition();\n};\n\ntips.prototype.resetPosition = function() {\n    this.event = {};\n    this.event.type = 'resize';\n    this.setPosition();\n}\n\ntips.prototype.render = function() {\n    let options = this.options;\n    this.backup._baseElm = this.getBaseElememt(options);\n    this.backup._tipGroupElm = this.getTipsGroup(options);\n    this.backup._tipContainerElm = this.getTipsContainer(options);\n    this.backup._backgroundElem = this.renderTipsBg(options);\n    this.backup._tipElm = this.renderTipsBody(options);\n    this.setPosition();\n};\n\ntips.prototype.animation = function(status) {\n    status = 'animation' + status.charAt(0).toUpperCase() + status.slice(1);\n    if(this[status]) {\n        this[status]();\n    }\n};\n\ntips.prototype.animationIn = function() {\n    let animationOption = this.options.animation;\n    let $tipGroup = this.backup._tipGroupElm;\n\n    if($tipGroup.querySelectorAll(\"[name=ohoTips]\").length <= 1) {\n        if(animationOption.customAmtFuntion) {\n            animationOption.customAmtFuntion.call(this, 'in');\n        }else {\n            let amtFun = animationOption.in;\n            amtFun = 'animationType' + amtFun.charAt(0).toUpperCase() + amtFun.slice(1);\n            if(this[amtFun]) {\n                this[amtFun]('in');\n            }else {\n                this.animationTypeDefault('in');\n            }\n        }\n    }else {\n        this.animationTypeDefault('in');\n    }\n};\n\ntips.prototype.animationOut = function() {\n    let animationOption = this.options.animation;\n    let $tipGroup = this.backup._tipGroupElm;\n\n    if($tipGroup.querySelectorAll(\"[name=ohoTips]\").length <= 1) {\n        if(animationOption.customAmtFuntion) {\n            animationOption.customAmtFuntion.call(this, 'out');\n        }else {\n            let amtFun = animationOption.out;\n            amtFun = 'animationType' + amtFun.charAt(0).toUpperCase() + amtFun.slice(1);\n            if(this[amtFun]) {\n                this[amtFun]('out');\n            }else {\n                this.animationTypeDefault('out');\n            }\n        }\n    }else {\n        this.animationTypeDefault('out');\n    }\n};\n\ntips.prototype.animationTypeDefault = function(status) {\n    this.animationTypeFade(status);\n};\n\n/**\n * 默认动画\n * 淡入淡出动画\n * @param    {[type]}                 status in - 显示 / out - 隐藏\n */\ntips.prototype.animationTypeFade = function(status) {\n    let $tip = this.backup._tipElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $bg = this.backup._backgroundElem;\n    if(status == 'in') {\n        C.addClass($tip, 'ohoTip-amt-fade');\n        if($bg) {\n            C.addClass($bg, 'ohoTip-bg-amt-fade');\n        }\n        \n        setTimeout(function(){\n            C.addClass($tip, 'in');\n            if($bg) {\n                C.addClass($bg, 'in');\n            }\n        }, 100);\n    }else if(status == 'out') {\n        setTimeout(function(){\n            C.addClass($tip, 'out');\n            if($bg) {\n                C.removeClass($bg, 'in');\n            }\n        }, 100);\n    }\n};\n\n/**\n * 折叠特效\n * 向下展开，向上收起\n * @param    {[type]}                 status in - 显示 / out - 隐藏\n */\ntips.prototype.animationTypeFold = function(status) {\n    let $tip = this.backup._tipElm;\n    let $bg = this.backup._backgroundElem;\n    if(status == 'in') {\n        let eleDetails = this.getElementDetails();\n        let tipStyle = {\n            height: eleDetails.tipHeight + 'px',\n        };\n\n        C.addClass($tip, 'ohoTip-amt-fold');\n        if($bg) {\n            C.addClass($bg, 'ohoTip-bg-amt-fold');\n        }\n        \n        setTimeout(function(){\n            C.addCss($tip, tipStyle);\n            if($bg) {\n                C.addClass($bg, 'in');\n            }\n        }, 100);\n        // 显示阴影\n        this.timeoutFoldId = setTimeout(function(){\n            C.addCss($tip, {overflow: 'visible'});\n        }, 300);\n    }else if(status == 'out') {\n        if(this.timeoutFoldId) clearTimeout(this.timeoutFoldId);\n        \n        C.addCss($tip, {overflow: 'hidden'});\n        setTimeout(function(){\n            C.addClass($tip, 'out');\n            if($bg) {\n                C.removeClass($bg, 'in');\n            }\n        }, 100);\n    }\n};\n\n/**\n * oho特效\n * 在基准元素中间由小到大弹出到定位位置，从定位位置由大到小消失在基准元素中间\n * @param    {[type]}                 status in - 显示 / out - 隐藏\n */\ntips.prototype.animationTypeOho = function(status) {\n    let $tip = this.backup._tipElm;\n    let $tipGroup = this.backup._tipGroupElm;\n    let $bg = this.backup._backgroundElem;\n\n    let startPosition = this.getPositionStyle('middle', false, true);\n    let startSize = {\n        width: 0,\n        height: 0\n    };\n    let startStyle = C.extend({}, startPosition, startSize, {'opacity': '1'});\n\n    let eleDetails = this.getElementDetails();\n    let tipGroupPosition = C.position($tipGroup);\n    let oldGroupStyle = $tipGroup.style.cssText;\n    let oldGroupStyleObj = {\n        top: tipGroupPosition.top,\n        left: tipGroupPosition.left,\n        width: eleDetails.tipGroupWidth,\n        height: eleDetails.tipGroupHeight,\n    };\n\n    if(status == 'in') {\n        C.addCss($tipGroup, {overflow: 'hidden'});\n\n        C.addCss($tip, {'opacity': '1'});\n        C.addCss($tipGroup, startStyle);\n        \n        setTimeout(function(){\n            C.addClass($tipGroup, 'ohoTip-amt-oho');\n\n            C.addCss($tipGroup, oldGroupStyleObj);\n            if($bg) {\n                C.addClass($bg, 'ohoTip-bg-amt-oho');\n                C.addClass($bg, 'in');\n            }\n        }, 1);\n        setTimeout(function(){\n            // 分组第二个Tip 使用默认动画，所以需要删除其他动画效果，避免默认动画效果冲突\n            C.removeClass($tipGroup, 'ohoTip-amt-oho');\n            $tipGroup.style.cssText = oldGroupStyle;\n        }, 201);\n    }else if(status == 'out') {\n        C.addCss($tipGroup, {overflow: 'hidden'});\n\n        // in 之后 会删除动画效果，out 需要将动画效果先添加回来\n        C.addClass($tipGroup, 'ohoTip-amt-oho');\n        if($bg) {\n            C.addClass($bg, 'ohoTip-bg-amt-oho');\n        }\n\n        C.addCss($tipGroup, oldGroupStyleObj);\n\n        setTimeout(function(){\n            C.addCss($tipGroup, startStyle);\n            if($bg) {\n                C.removeClass($bg, 'in');\n            }\n        }, 1);\n    }\n};\n\n/**\n * 玻璃碎片特效\n * Tips 由碎片合成整体展示，Tips 由整体分裂成碎片消失\n * @param    {[type]}                 status in - 显示 / out - 隐藏\n */\ntips.prototype.animationTypeFragment = function(status) {\n    let $tipGroup = this.backup._tipGroupElm;\n    let $tip = this.backup._tipElm;\n    let $bg = this.backup._backgroundElem;\n    if(status == 'in') {\n        C.addClass($tip, 'ohoTip-amt-fragment in');\n        if($bg) {\n            C.addClass($bg, 'ohoTip-bg-amt-fragment in');\n        }\n\n        this.fragmentInExplode();\n    }else if(status == 'out') {\n        this.fragmentOutExplode();\n\n        let tipStyle = {\n            display: 'none',\n        };\n        C.addCss($tip, tipStyle);\n    }\n}\n\ntips.prototype.createTipCopy = function(hideTip) {\n    let $tip = this.backup._tipElm;\n    let $tipClone = $tip.cloneNode(true);\n\n    C.insertAfter($tipClone, $tip);\n\n    if(hideTip == true){\n        $tip.style.display = \"none\";\n    }\n\n    return $tipClone;\n}\n\ntips.prototype.createFragment = function() {\n    let $tipClone = this.createTipCopy(true);\n\n    let tipWidth = C.outerWidth($tipClone), tipHeight = C.outerHeight($tipClone);\n    C.addCss($tipClone, {width: tipWidth+'px', height: tipHeight+'px'});\n    let tipHtml = $tipClone.innerHTML;\n    $tipClone.innerHTML = '';\n    \n    let animationOption = this.options.animation;\n    let xCount = animationOption.fragments.xCount,\n        yCount = animationOption.fragments.yCount,\n        fWidth = tipWidth/xCount,\n        fHeight = tipHeight/yCount;\n\n    let x=0, y=0, rectLeft=0, rectTop=0, fNode;\n    for(y=0; y<yCount; y++) {\n        rectTop = y*fHeight;\n        for(x=0; x<xCount; x++) {\n            rectLeft=x*fWidth;\n            fNode = C.createNode('<div class=\"ohoTip-amt-fragment-box\" style=\"clip: rect('+rectTop+'px, '+(rectLeft+fWidth)+'px, '+(rectTop+fHeight)+'px, '+rectLeft+'px)\">'+tipHtml+'</div>');\n            $tipClone.appendChild(fNode);\n        }\n    }\n\n    return $tipClone;\n}\n\ntips.prototype.fragmentInExplode = function() {\n    let $tip = this.backup._tipElm;\n\n    let $tipClone = this.createFragment();\n\n    $tipClone.querySelectorAll('div[class=\"ohoTip-amt-fragment-box\"]').forEach(item => {            \n        let randTop = C.randomNum(-10, 10),\n            randLeft = C.randomNum(-10, 10);\n\n        let randDeg = C.randomNum(-5, 15), \n            randScale = C.randomNum(0.7, 1.3),\n            randDeg2 = C.randomNum(5, 25);\n\n        C.addCss(item, {'top' : (randTop)+'px', 'left' : (randLeft)+'px', 'opacity' : '0', 'transform' : 'scale('+randScale+') skew('+randDeg+'deg) rotateZ('+randDeg2+'deg)'});\n        \n        setTimeout(function() {\n            C.addClass(item, 'explode-in');\n            C.addCss(item, {'left' : '0', 'top' : '0', 'opacity' : '1', 'transform' : 'none'});\n        }, 10);\n    })\n\n    setTimeout(function() {\n        $tipClone.parentNode.removeChild($tipClone);\n        C.addCss($tip, {display: ''});\n    }, 1000);\n}\n\ntips.prototype.fragmentOutExplode = function() {\n    let $tipClone = this.createFragment();\n    \n    let tipWidth = C.outerWidth($tipClone), tipHeight = C.outerHeight($tipClone);\n\n    $tipClone.querySelectorAll('div[class=\"ohoTip-amt-fragment-box\"]').forEach(item => {\n        C.addClass(item, 'explode-out');\n        \n        let randTop = C.randomNum(-30, 30);\n        let randLeft = C.randomNum(-30, 30);\n\n        let randDeg = C.randomNum(-5, 10), \n        randScale = C.randomNum(0.9, 1.5),\n        randDeg2 = C.randomNum(30, 5);\n\n        C.addCss(item, {'top' : (randTop)+'px', 'left' : (randLeft)+'px', 'opacity' : '0', 'transform' : 'scale('+randScale+') skew('+randDeg+'deg) rotateZ('+randDeg2+'deg)'});\n    })\n\n    setTimeout(function() {\n        $tipClone.parentNode.removeChild($tipClone);\n    }, 1000);\n\n    this.options.animation.delay = 1010;\n}\n\ntips.prototype.fragmentOutFlow = function() {\n    let $tipClone = this.createFragment();\n\n    let fragments = $tipClone.querySelectorAll('div[class=\"ohoTip-amt-fragment-box\"]');\n    let animationOption = this.options.animation;\n    let xCount = animationOption.fragments.xCount,\n        yCount = animationOption.fragments.yCount;\n    let fHeight = C.outerHeight($tipClone)/yCount;\n    \n    let x=0, y=0, curTimeout=0, maxTimeout=0;\n    for(y=0; y<yCount; y++) {\n        let top = y*fHeight+5;\n        for(x=0; x<xCount; x++) {\n            curTimeout = x*30;\n            maxTimeout = maxTimeout > curTimeout? maxTimeout : curTimeout;\n            let k = y*xCount + x;\n            setTimeout(function() {\n                if(fragments[k] === undefined) return;\n\n                fragments[k].style.top = top + \"px\";\n                fragments[k].style.opacity = 0;\n                // fragments[k].style.transform = \"rotate(360deg) scale(0)\";\n            }, curTimeout);\n        }\n    }\n    setTimeout(function() {\n        $tipClone.parentNode.removeChild($tipClone);\n    }, curTimeout+100);\n\n    // Will remove All the tips element after delay\n    this.options.animation.delay = curTimeout+100;\n}\n\n/**\n * 监听窗口大小发生改变，重新定位\n *\n * 注意窗口大小改变（resize） 500毫秒内 立刻上下滚动（scroll），需要立即重新定位一次。\n * 原因是 getElementDetails 只有 resize 才会重新获取\n */\ntips.prototype.listen = function() {\n    let _this = this;\n\n    let lastEvent = null;\n\n    let triggerSetPosition = function(e) {\n        _this.writeLog('info', \"Trigger Set Position: \", e);\n        _this.event = e;\n        _this.setPosition();\n\n        // setTimeout(function(){_this.event = null;}, 1);\n        _this.event = null;\n    }\n\n\n    _this.backup.bind = function(e) {\n        // _this.writeLog('info', \"Trigger Event: \", e);\n\n        if(lastEvent && lastEvent.type == 'resize' && e.type != 'resize') {\n            _this.writeLog('info', \"Trigger Event type was changed from %s to %s, need to set position immediately.\", lastEvent.type, e.type);\n            triggerSetPosition(lastEvent);\n        }\n\n        lastEvent = e;\n\n        if(_this.eventTimeoutID) clearTimeout(_this.eventTimeoutID);\n        _this.eventTimeoutID = setTimeout(function() {\n            triggerSetPosition(e);\n        }, 10);\n    }\n    window.addEventListener('resize', _this.backup.bind);\n    window.addEventListener('scroll', _this.backup.bind);\n};\n\ntips.prototype.unlisten = function() {\n    let _this = this;\n    window.removeEventListener('resize', _this.backup.bind);\n    window.removeEventListener('scroll', _this.backup.bind);\n};\n\ntips.prototype.clearTimeout = function() {\n    if(this.floatOptions && this.floatOptions.hasOwnProperty('floatId') && this.floatOptions.floatId) clearInterval(this.floatOptions.floatId);\n}\n\ntips.prototype.deleteGroup = function() {\n}\n\n//移除Tips 元素\ntips.prototype.destroy = function() {\n    let _this = this;\n    let $tipContainer = _this.backup._tipContainerElm;\n    let $tipGroup = _this.backup._tipGroupElm;\n    let $tip = _this.backup._tipElm;\n    let $bg = _this.backup._backgroundElem;\n    let $symbol = _this.backup._symbolElm;\n\n    this.options.events.beforeDestroyed.call(this);      //Tips 销毁之前 触发\n\n    _this.animation('out');\n\n    setTimeout(function() {\n        $tip.remove();\n        if($bg) {\n            $bg.remove();\n        }\n\n        // 一个组只有一个Symbol，当组内只剩下一个元素的时候，说明它是Symbol\n        if($symbol) {\n            if($tipGroup.getElementsByTagName(\"*\").length == 1) {\n                $symbol.remove();\n            }\n        }\n\n        if($tipGroup.getElementsByTagName(\"*\").length == 0) {\n            $tipGroup.remove();\n        }else {\n            // 用于显示symbol\n            C.addCss($tipGroup, {overflow: 'visible'});\n            _this.resetPosition();\n        }\n\n        if($tipContainer.getElementsByTagName(\"*\").length == 0) {\n            $tipContainer.remove();\n        }\n\n        //取消监听\n        _this.unlisten();\n\n        _this.clearTimeout();\n\n        _this.unsetGroup();\n\n        _this.options.events.destroyed.call(_this);        //Tips 销毁之后 触发\n    }, _this.options.animation.delay);\n}\n\ntips.prototype.setDestroy = function() {\n    let _this = this;\n    let $tipBox = _this.backup._tipBoxElm;\n    let $bg = _this.backup._backgroundElem;\n\n    if(this.options.destroy == 'auto') {      //自动销毁tips\n        let delay = this.options.delay;\n        setTimeout(function(){\n            _this.destroy();\n        }, delay);\n    }else if(this.options.destroy == 'manual') {     //手动销毁tips\n        let $close = C.createNode(\"<div class='ohoTip-close'>x</div>\");\n        $tipBox.appendChild($close);\n\n        $close.onclick = function() {\n            _this.destroy();\n        };\n    }else {\n        // 从不销毁\n    }\n};\n\ntips.prototype.initTips = function() {\n    this.initMsg();\n    this.setClass();                //获取class\n    this.setTipsAttribute();        //获取属性\n    this.render();\n    this.setGroup();\n\n    this.options.events.beforeShown.call(this);  //Tips 创建消息之后，展示之前 触发\n\n    this.animation('in');\n    this.listen();\n    this.setDestroy();\n\n    this.options.events.shown.call(this);        //Tips 展示之后 触发\n};\n\ntips.prototype.uniqueId = function() {\n   let date = new Date();\n   let y = date.getFullYear();\n   let m = date.getMonth() + 1;\n   m = m < 10 ? ('0' + m) : m;\n   let d = date.getDate();\n   d = d < 10 ? ('0' + d) : d;\n   let h = date.getHours();\n   let minute = date.getMinutes();\n   let second = date.getSeconds();\n\n   let randomStr = Math.random().toString(36).substr(2);\n\n   return y + m + d + h + minute + second + randomStr;\n}\n\ntips.prototype.show = function(message, type, baseElement) {\n    let options = {\n        baseElement: baseElement,\n        type: type,\n        message: message\n    };\n    this.init(options);\n};\n\ntips.prototype.normal = function(message, icon, baseElement) {\n    let options = {\n        baseElement: baseElement,\n        type: \"normal\",\n        icon: icon? icon : 'info',\n        message: message\n    };\n    this.init(options);\n};\n\ntips.prototype.info = function(message, baseElement) {\n    let options = {\n        baseElement: baseElement,\n        type: \"info\",\n        message: message\n    };\n    this.init(options);\n};\n\ntips.prototype.success = function(message, baseElement) {\n    let options = {\n        baseElement: baseElement,\n        type: \"success\",\n        message: message\n    };\n    this.init(options);\n};\n\ntips.prototype.error = function(message, baseElement) {\n    let options = {\n        baseElement: baseElement,\n        type: \"error\",\n        message: message\n    };\n    this.init(options);\n};\n\ntips.prototype.warning = function(message, baseElement) {\n    let options = {\n        baseElement: baseElement,\n        type: \"warning\",\n        message: message\n    };\n    this.init(options);\n};\n\ntips.prototype.hoverTip = function(options, hoverElement) {\n    let defOptions = {\n        symbol: 'triangle'\n    };\n    let hoverTip;\n    options = C.extend({}, defOptions, options);\n\n    hoverElement.onmouseenter = function() {\n        hoverTip = ohoTips(options);\n    }\n    hoverElement.onmouseleave = function() {\n        if(hoverTip) hoverTip.destroy();\n    }\n};\n\n//jQuery 拓展静态方法 tips\nif(typeof jQuery != 'undefined'){\n    $.extend({\n        ohoTips: function(options, extendOptions = {}) {\n            return new tips(options, extendOptions);\n        }\n    });\n}\n\nfunction ohoTips(options, extendOptions = {}) {\n    return new tips(options, extendOptions);\n}\n\n\n\n//# sourceURL=webpack://oho/./src/ohoTips/js/ohoTips.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ohoTips/js/ohoTips.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});